# 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

> **결국 TC39는 런타임 기능을 발전시키고, 타입스크립트 팀은 타입 기능만발전시킨다는 명확한 원칙을 세우고 현재까지 지켜오고 있습니다. 그런데 이 원칙이 세워지기 전에, 이미 사용되고 있던 몇 가지 기능이 있습니다. 이 기능들은 타입 공간(타입스크립트)과 값 공간(자바스크립트)의 경계를 혼란스럽게 만들기 때문에 사용하지 않는 것이 좋습니다.**

- 열거형(enum)
  - 숫자 열거형은 0, 1, 2 외의 다른 숫자가 할당되면 위험하다.
  - 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다.
  - 문자열 열거형은 타입스크립트의 다른 타입과 달리 구조적 타이핑이 아닌 명목적 타이핑(nominally typing)을 사용한다.
    - 명목적 타이핑은 타입의 이름이 같아야 할당이 허용된다.
    - 타입스크립트와 자바스크립트에서 동작이 다르다.
- 매개변수 속성
  ```tsx
  class Person {
    constructor(public name: string) {}
  }

  // public name => 매개변수 속성 예
  ```
  - 컴파일 시 코드가 늘어난다.
  - 런타임에서 사용되지만, 타입스크립트에서는 사용되지 않는 것처럼 보인다.
  - 일반 속성을 섞어 사용하면 혼란스러워진다.
- 네임스페이스와 트리플 슬래시 임포트
  - ECMAScript 2015 이후 공식적으로 모듈 시스템이 도입되자, 타입스크립트에서 이전까지 사용하던 트리플 슬래시 임포트와 구분하기 위해 namespace 키워드를 도입했다.
  - 이제는 사용하지 말자.
- 데코레이터
  - 데코레이터는 앵귤러를 사용하거나 애너테이션이 필요한 것이 아니면 사용하지 말자.

# 아이템 54. 객체를 순회하는 노하우

```tsx
const obj = {
  one: "uno",
  two: "dos",
  three: "tres",
};
for (const k in obj) {
  const v = obj[k]; // obj에 인덱스 시그니처가 없기 때문에 엘리먼트는 암시적으로 'any' 타입
}

// k의 타입은 string으로 추론되는 반면, obj 객체에는 특정 키만 존재하기 때문에 오류 발생

let k: keyof typeof obj;
for (k in obj) {
  const v = obj[k];
}

// k의 타입을 더욱 구체적으로 명시해주어 오류 해결
```

- 왜일까?
  - 특정 객체 타입에는 그 외에 할당 가능한 다른 속성이 존재할 수 있다.
  - 그러므로 타입스크립트는 객체의 키를 string 타입으로 선택하는게 합당하다.
  - 하지만 keyof 키워드로 한정지으면 string | number로 추론되어 적합하지 못하다.
  - `Object.entries` 를 사용하자

```tsx
function foo(abc: ABC) {
  for (const [k, v] of Object.entries(abc)) {
    k; // string
    v; // any
  }
}
```

- keyof 선언은 상수이거나 추가적인 키 없이 정확한 타입을 원할 경우
- Object.entries는 더욱 일반적으로 쓰이지만, 키와 값의 타입을 다루기 까다롭다.

# 아이템 55. DOM 계층 구조 이해하기

> **타입스크립트에서는 DOM 엘리먼트의 계층 구조를 파악하기 용이합니다.**

1. EventTarget
   1. DOM 타입 중 가장 추상화된 타입
   2. 이벤트 리스너 추가 및 제거, 이벤트 보내는 것 가능
   3. Event의 currnetTarget 속성은 EventTarget | null 이므로 핸들링 해주어야 함
2. Node
   1. 텍스트 조각, 주석
3. Element, HTMLElement
   1. SVG 태그의 계층 구조를 포함하며 HTML이 아닌 엘리먼트: SVGElement
4. HTMLxxxElement
   1. 자신만의 고유 속성 보유
5. Event
   1. UIEvent
   2. MouseEvent
   3. TouchEvent
   4. WheelEvent
   5. KeyboardEvent

# 아이템 56. 정보를 감추는 목적으로 private 사용하지 않기

> **타입스크립트에는 public, protected, private 접근 제어자를 사용해서 공개 규칙을 강제할 수 있는 것으로 오해할 수 있습니다. 그러나 public, protected, private 같은 접근 제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거됩니다.**

- 자바스크립트에서 정보를 숨기기 위해 가장 효과적인 방법은 클로저를 사용하는 것이다.
  - 메모리 낭비와 생성된 인스턴스 간 비공개 데이터 접근에 불편함이 있다.
  - 클로저 방식은 동일 클래스의 개별 인스턴스 간에 속성 접근이 불가능하다.
- 현재 표준화가 진행중인 비공개 필드 기능
  ```tsx
  class PasswordChecker {
    #passwordHash: number;

    constructor(passwordHash: number) {
      this.#passwordHash = passwordHash;
    }
  }
  ```
  - 클로저 기법과 다르게 클래스 메서드나 동일 클래스의 개별 인스턴스끼리 접근 가능

# 아이템 57. 소스맵을 사용하여 타입스크립트 디버깅하기

> **디버깅을 하면 보게 되는 코드는 전처리기, 컴파일러, 압축기를 거친 자바스크립트 코드일 겁니다. 이렇게 변환된 자바스크립트 코드는 복잡해 디버깅하기 매우 어렵습니다. 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑합니다.**

- 타입스크립트와 함께 번들러나 압축기를 사용하면 각자의 소스맵을 생성한다. 생성된 자바스크립트가 아닌 원본 타입스크립트 소스로 매핑되도록 해야한다.
- 상용 환경에 소스맵이 유출되는지 확인해야 한다. 소스맵에 원본 코드의 복사본이 포함된다면 주석이나 기타 개발용 코드가 포함될 수 있으므로 주의해야 한다.
