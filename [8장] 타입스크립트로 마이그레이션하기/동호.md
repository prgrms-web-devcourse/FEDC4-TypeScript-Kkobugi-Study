# ch08. 타입스크립트로 마이그레이션하기

---

> 덩치 크고 낡은 자바스크립트 프로젝트를 꾸준히 타입스크립트로 마이그레이션하는 방법들
> 

## 아이템 58 모던 자바스크립트로 작성하기

---

### 요약

- 타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로 모던 자바스크립트의 최신 기능들을 적극적으로 사용하시길 발바니다. 코드 품질을 향상시킬 수 있고, 타입스크립트의 타입 추론도 더 나아집니다.
- 타입스크립트 개발 환경에서는 컴파일러와 언어 서비스를 통해 클래스, 구조 분해, async/await 같은 기능을 쉽게 배울 수 있습니다.
- ‘use strict’는 타입스크립트 컴파일러 수준에서 사용되므로 코드에서 제거해야 합니다.
- TC39의 깃헙 저장소와 타입스크립트의 릴리스 노트를 통해 최신 기능을 확인할 수 있습니다.

---

> ***ES2015(ES6) 버전부터 모던 자바스크립트라고 부를 수 있다.***
> 

타입스크립트에는 타입 체크 기능 외에 특정 버전의 자바스크립트 코드로 컴파일하는 기능도 가지고 있다. 타입스크립트 컴파일러를 트랜스파일러로 사용할 수 있기 때문에, 예전 버전의 자바스크립트가 타입스크립트 컴파일러로 동작한다면 이를 최신 버전의 자바스크립트 코드로 변환해도 문제가 없다.

마이그레이션을 어디서부터 시작해야할 지 막막하다면 최신 버전의 자바스크립트로 바꾸는 작업으로 시작을 해도 좋다.

### 모던 자바스크립트의 주요 기능들 소개

- **ECMAScript 모듈 사용하기**
    - `import`, `export` 와 같은 표준 모듈을 사용할 것
- **프로토타입 대신 클래스 사용하기**
    - 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꿔라
    - 간결하고 직관적
- **var 대신 let/const 사용하기**
    - var의 스코프, 호이스팅 문제
- ****************************************************************************************************************for(;;) 대신 for-of 또는 배열 메서드 사용하기****************************************************************************************************************
    - C 스타일의 for 루프 사용하지 말고 for-of, forEach() 등을 사용하라
    - 코드가 짧고 인덱스 변수를 사용하지 않아 실수를 줄일 수 있다.
    - for-in 문법은 몇 가지 문제점이 있기에 사용하지 않는 것이 좋다. (아이템16)
        - 타입이 불확실할 경우, for-in 루프는 for-of 또는 C스타일 for 루프에 비해 몇 배나 느림
- **함수 표현식보다 화살표 함수 사용하기**
    - 인라인 혹은 콜백에서는 일반 함수보다 화살표 함수가 더 직관적이며 코드가 간결함
    - 컴파일러 옵션에 `noImplicitThis(또는 strict)`를 설정하면 this 바인딩 오류를 표시해줌
- **단축 객체 표현과 구조 분해 할당 사용하기**
    - 단축 객체 표현: `const pt = { x: x, y: y}` ⇒ `const pt = { x, y }`
    - 구조 분해 할당: `const props = obj.props` ⇒ `const { props } = obj`
    - 문법이 간결해지고 변수 사용 실수를 줄일 수 있음
- **함수 매개변수 기본값 사용하기**
- **저수준 프로미스나 콜백 대신 async/await 사용하기**
    - 간결해져서 버그나 실수를 방지하고 비동기 코드에 타입 정보가 전달되어 타입 추론이 가능
- **연관 배열에 객체 대신 Map과 Set 사용하기**
    - 인덱스 시그니처는 편리하지만 몇 가지 문제점이 존재
        
        ```tsx
        // 문자열 내의 단어 개수를 세는 함수
        function countWords(text: string) {
        	const counts: {[word: string]: number} = {};
        	for (const word of text.split(/[\s,.]+/)) {
        		counts[word] = 1 + (counts[word] || 0);
        	}
        	return counts;
        }
        ```
        
        - constructor라는 특정 문자열이 주어지면 문제가 발생한다.
        - `console.log(countWords('Objects have a constructor'));`
        
        ```tsx
        {
        	Objects: 1,
        	have: 1,
        	a: 1,
        	constructor: "1function Object() { [native code] }"
        }
        ```
        
        - constructor의 초깃값은 undefined가 아니라 Object.prototype에 있는 생성자 함수다.
        - 타입도 number가 아닌 string이다.
    - 이러한 문제를 방지하려면 Map을 사용하자.
- **타입스크립트에 use strict 넣지 않기**
    - use strict보다 타입스크립트의 안전성 검사가 훨씬 더 엄격하기에 무의미해짐
    - 실제로 타입스크립트 컴파일러가 생성한 자바스크립트 코드에는 ‘use strict’가 포함됨
    - 코드에 쓰지 말고, 컴파일러 옵션에서 `alwaysStrict` 또는 `strict` 옵션을 키자

## 아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

---

### 요약

- 파일 상단에 `// @ts-check`을 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있습니다.
- 전역 선언과 서드파티 라이브러리의 타입 선언을 추가하는 방법을 익힙시다.
- JSDoc 주석을 잘 활용하면 자바스크립트 상태에서도 타입 단언과 타입 추론을 할 수 있습니다.
- JSDoc 주석은 중간 단계이기 때문에 너무 공들일 필요는 없습니다. 최종 목표는 `*.ts*`로 된 타입스크립트 코드임을 명심합시다.

---

### `// @ts-check` 지시자

타입스크립트 전환 시에 어떤 문제가 발생하는지 미리 시험해볼 수 있는 지시자로, 느슨한 수준으로 타입 체크를 수행한다는 점을 주의하자. (`noImplicitAny` 설정을 해제한 것보다 헐거운 체크를 수행)

**사용법**

```tsx
// @ts-check
const person = {first: 'Grace', last: 'Hopper'};
2 * person.first
// ~~~~~~~~~~~~~ 산술 연산 오른쪽은 'any', 'number', 'bigint'
//               또는 열거형 형식이어야 합니다.
```

- `person.first` 타입은 string으로 추론, `2 * person.first`는 타입 불일치 오류가 되었다.
- @ts-check 지시자 덕분에 자바스크립트임에도 불구하고 타입 체크가 동작한다.

**선언되지 않은 전역 변수**

변수를 선언할 때 보통 let, const를 사용하는데, 어딘가에 숨어있는 변수 (예를 들어 html 파일 내의 <script> 태그)가 있다면 변수를 제대로 인식할 수 있게 별도의 타입 선언 파일을 만들어야 한다.

만약, 선언 파일을 찾지 못하는 경우에는 ‘트리플 슬래시’ 참조를 사용하여 명시적으로 임포트할 수 있다.

**알 수 없는 라이브러리**

서드 파티 라이브러리의 타입 정보가 없다면 ts-check이 오류를 발생시킨다. 타입 선언을 설치하고 사용하면 오류가 사라진다.

********************DOM 문제********************

타입스크립트라면 DOM 요소에 단언문을 사용하겠지만, 자바스크립트 코드에 단언문을 쓸 수는 없다. 대신 JSDoc을 사용하면 타입 단언을 대체할 수 있다.

```tsx
// @ts-check
const ageEl = /** @type {HTMLInputElement} */(document.getElementById('age'));
ageEl.value = '12'; // 정상
```

**부정확한 JSDoc**

그런데 이미 존재하던 JSDoc 스타일 주석이 있었다면 ts-check 지시자를 설정하는 순간에 기존 주석에 타입 체크가 동작하여 수많은 오류가 발생할 수 있다.

- DOM 타입 불일치로 인한 오류
- @return 태그에 명시된 타입과 실제 반환 타입이 맞지 않아 발생하는 오류 등
- 오류를 수정하고 타입스크립트에서 지원하는 타입 자동 생성 기능을 사용해볼 수 있으나, 잘 동작하지 않는 경우도 많다.

⇒ **ts-check 지시자와 JSDoc은 타입스크립트 기반으로 전환하는 초석일 뿐이기에 오래 사용하지 말자. 이미 JSDoc 주석 스타일을 사용한 레거시 코드라면 ts-check 지시자만 간단히 추가해서 타입 체커를 실험하여 초기 오류를 빠르게 잡는 용도로만 사용하자.**

## 아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기

---

### 요약

- 점진적 마이그레이션을 위해 자바스크립트와 타입스크립트를 동시에 사용할 수 있게 `allowJs` 컴파일러 옵션을 사용합시다.
- 대규모 마이그레이션 작업을 시작하기 전에, 테스트와 빌드 체인에 타입스크립트를 적용해야 합니다.

---

소규모 프로젝트는 한꺼번에 타입스크립트로 마이그레이션이 가능하지만,
**대규모 프로젝트는 한꺼번에 작업하는 것은 불가능하므로 점진적으로 전환할 수 있어야 한다.**

### allowJs 컴파일러 옵션

이 옵션은 타입스크립트와 자바스크립트가 공존할 수 있도록 한다.

- `ts` 파일과 `js` 파일을 서로 임포트할 수 있게 해준다.
- 기존 빌드 과정에 타입스크립트 컴파일러를 추가할 수 있다.
- 유닛 테스트를 위해서 사용되는 플러그인 들이 있다.
    - ts-jest 등

이 옵션을 설정하면 점진적으로 마이그레이션을 할 수 있게 해준다.

## 아이템 61 의존성 관계에 따라 모듈 단위로 전환하기

---

### 요약

- 마이그레이션의 첫 단계는, 서드파티 모듈과 외부 API 호출에 대한 @types를 추가하는 것입니다.
- 의존성 관계도의 아래에서부터 위로 올라가며 마이그레이션을 하면 됩니다. 첫 번째 모듈은 보통 유틸리티 모듈입니다. 의존성 관계도를 시각화하여 진행 과정을 추적하는 것이 좋습니다.
- 이상한 설계를 발견하더라도 리팩터링을 하면 안됩니다. 마이그레이션 작업은 타입스크립트 전환에 집중해야 하며, 나중의 리팩터링을 위해 목록을 만들어 두는 것이 좋습니다.
- 타입스크립트로 전환하며 발견하게 되는 일반적인 오류들을 놓치지 않아야 합니다. 타입 정보를 유지하기 위해 필요에 따라 JSDoc 주석을 활용해야 할 수도 있습니다.

---

점진적 마이그레이션을 하려면 모듈 단위로 각개격파

→ 그러나 해당 모듈이 의존하는 모듈에서 타입 오류가 발생할 수 있다.

→ 다른 모듈에 의존하지 않는 최하단 모듈부터 작업하여 최상단 모듈을 마지막으로 완성하자.

### madge

[https://github.com/pahen/madge](https://github.com/pahen/madge)

- 프로젝트의 의존성 관계도를 만들어주는 도구
- 의존성 관계도를 시각화해줌

### 리팩터링은 하지 마라

마이그레이션할 때는 리팩터링을 하지 말고 타입 정보만 추가하라.

당장의 코드 개선이 목표가 아니라 타입스크립트로 전환하는 것이 주된 목표가 되어야 한다.

### 선언되지 않은 클래스 멤버

자바스크립트에서는 클래스에서 멤버 변수를 선언할 필요가 없지만, 타입스크립트는 명시적으로 멤버 변수를 선언해야 하므로 클래스 문법에서 오류가 발생한다.

- **quick fix(빠른 수정)** 기능으로 간단히 해결할 수 있다.
- **‘Add all missing members’**를 선택하면 타입을 추론하여 선언문이 모두 추가된다.
- 추가된 선언문에 `any`로 추론된 속성이 있다면 직접 수정하자.

### 타입이 바뀌는 값

다음 코드는 자바스크립트에서는 문제가 없지만 타입스크립트에서는 오류가 발생한다.

```tsx
const state = {};
state.name = 'New York';
		//~~~~ '{}' 유형에 'name' 속성이 없습니다.
state.capital = 'Albany';
		//~~~~~~~~ '{}' 유형에 'capital' 속성이 없습니다.
```

- 한꺼번에 객체를 생성하면 오류를 간단히 해결할 수 있다.

```tsx
const state = {
	name: 'New York',
	capital: 'Albany',
}; // 정상
```

- 이 방법이 곤란하면 임시 방편으로 타입 단언문을 사용한다.

```tsx
interface State {
	name: string;
	capital: string;
}
const state = {} as State;
state.name = 'New York';
state.capital = 'Albany';
```

### JSDoc과 @ts-check 지시자가 사용된 상태

이 상태에서는 타입스크립트로 전환하는 순간 타입 정보가 무효화된다는 것을 주의하자. 다행히, JSDoc 타입 정보를 타입스크립트 타입으로 전환해주는 빠른 수정(quick fix) 기능을 사용하면 된다.

## 아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기

---

### 요약

- `noImplicitAny` 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 합니다. `noImplicitAny` 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않습니다.
- `noImplicitAny`를 전면 적용하기 전에 로컬에서부터 탕비 오류를 점진적으로 수정해야 합니다. 엄격한 타입 체크를 적용하기 전에 팀원들이 타입스크립트에 익숙해질 수 있도록 시간을 줍시다.

---

프로젝트 전체를 `.ts`로 전환했다면 매우 큰 진척을 이룬 것이다. 마지막으로 `noImplicitAny`를 설정하여 타입 선언에서 비롯되는 실제 오류를 수정하자.

**처음에는** 원격에서는 설정에 변화가 없기 때문에 빌드가 실패하지 않도록 하고, `noImplicitAny`를 로컬에만 설정하고 작업하는 것이 좋다. 수정한 부분만 커밋하여 점진적으로 마이그레이션한다.

`noImplicitAny`는 상당히 엄격한 설정이며, `strictNullChecks`같은 설정을 적용하지 않더라도 대부분의 타입 체크를 적용한 것으로 볼 수 있다.

최종적으로 가장 강력한 설정은 `"strict": true`다. 타입 체크의 강도는 팀 내의 모든 사람이 타입스크립트에 익숙해진 다음에 조금씩 높여가면 좋다.