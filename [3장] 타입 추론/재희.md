# 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

> **타입 추론이 된다면 명시적 타입 구문은 필요하지 않습니다.**

> **타입스크립트는 여러분이 예상한 것보다 더 정확하게 추론하기도 합니다.**

> **타입이 추론되면 리팩터링 역시 용이해집니다.**

- 객체의 요소를 사용할 때는 명시적으로 처리해주는 것보다는 비구조화 할당문을 사용하면 좋다.
  - 모든 지역 변수의 타입이 추론되도록 하기 때문
- 명시적 타입 구문이 필요한 때도 있다.
- 타입스크립트는 최종 사용처까지 고려하지 않는다.
- 기본값이 있는 경우는 함수 매개변수 타입 구문을 생략하기도 한다.

> **보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론됩니다.**

> **타입 추론이 가능할지라도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위해 타입 구문을 명시하는게 좋습니다.**

- 타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 상황
  - 객체 리터럴을 정의할 때 - 잉여 속성 체크를 위해
- 함수의 반환에 타입을 명시하는 경우

- 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있다.
- 명명된 타입을 사용할 수 있다.

  ```tsx
   interface Vertor2D {
  	x: number
  	y: number
  }

  function (): Vector2D {...}
  // 위 처럼 하지 않아도 반환이 {x: number, y:number} 식이면 문제가 없지만 사용자 입장에서는 헷갈릴 수 있다.

  ```

- eslint 규칙 중 `no-inferrable-types` 규칙을 통해 작성된 모든 타입 구문이 정말 필요한지 확인할 수 있다.

# 아이템 20. 다른 타입에는 다른 변수 사용하기

> **여기서 “변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다”는 중요한 관점을 알 수 있습니다.**

- 자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 된다.
  - 타입스크립트에서는 오류가 발생한다.
- 타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것이다.
  - 유니온 타입을 사용하는 등
- 별도의 변수를 도입하는 것이 낫다.
- ‘가려지는(shadowed)’ 변수는 문제가 없지만 사용자에게 혼란을 줄 수 있으니 사용하지 말자.

# 아이템 21. 타입 넓히기

> **상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 합니다. 이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻입니다. 타입스크립트에서는 이러한 과정을 ‘넓히기(widening)’라고 부릅니다.**

- 한 상수 값에 대하여 타입으로 추론될 수 있는 꽤 많은 경우의 수가 있다.
- 타입스크립트는 작성자의 의도를 추측하지만, 항상 옳은 것은 아니다.
- let 대신 const를 사용하면 더 좁은 타입으로 추론이 가능하다.
- 하지만 객체나 배열의 경우에는 더 많은 고려가 필요하다.

> **타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 합니다. 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않습니다.**

- 타입 추론의 강도를 제어하기 위해 기본 동작을 재정의하는 세 가지 방법

  1. 명시적 타입 구문 제공
  2. 타입 체커에 추가적인 문맥을 제공
     1. 함수의 매개변수로 값을 전달 등…
  3. const 단언문을 사용

  ```tsx
  const v1 = {
    x: 1,
    y: 2,
  }; // 타입은 { x: number; y: number;}

  const v2 = {
    x: 1 as const,
    y: 2,
  }; // 타입은 { x: 1; y: number;}

  const v3 = {
    x: 1,
    y: 2,
  } as const; // 타입은 { readonly x: 1; readonly y: 2;}
  ```

  - 값 뒤에 `as const` 를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다.

# 아이템 22. 타입 좁히기

- truthy 값을 이용한 null 체크
- `instanceof` 를 사용한 타입 좁히기
- 속성 체크

```tsx
interface A {
  a: number;
}
interface B {
  b: number;
}
function pickAB(ab: A | B) {
  if ("a" in ab) {
    ab; // 타입이 A
  } else {
    ab; // 타입이 B
  }
  ab; // 타입이 A | B
}
```

- `Array.isArray` 등의 내장함수 사용
- tagged union, discriminated union을 사용하여 타입 좁히기
- 커스텀 함수 도입

```tsx
function isInputElement(el: HTMLElement): el is HTMLElement {
  return "value" in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // 타입이 HTMLInputElement
    return el.value;
  }
  el; // 타입이 HTMLElement
  return el.textContent;
}

// 이러한 기법을 '사용자 정의 타입 가드'라고 한다.
// 반환 타입의 el is HTMLInputElement는 함수의 반환이 true인 경우, 타입 체커에게 매개변수의 타입을 좁힐 수 있다고 알려준다.
```

- 타입스크립트가 의도를 파악하지 못하는 경우

```tsx
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(who => who !== undefined); // 타입이 (string | undefined)[]

// 타입 가드 사용
function isDefined<T>(x: T | undefined): x is T {
	return x !== undefined;
}
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(isDefined);

// 또는
filter((who):who is string => who !== undefined); // as 를 사용하는 것만큼 안전하지 않음...

왜 filter()로 추론이 되지 않을까?
'모든 자바스크립트는 타입스크립트이다'

arr.filter((x): x is number => x === undefined) 의 경우 옳지 않다.
filter 함수는 boolean 값을 반환하여 필터링을 수행할 뿐,
내부 구현을 확인하여 타입을 확정짓는 과정과는 차이가 있다.

filter<S extends T>(cb: (value: T) => value is S): S[];
이런 식의 타입스크립트 구현은 자바스크립트 동작과 거리가 있다.

```

# 아이템 23. 한꺼번에 객체 생성하기

- 객체는 한 번에 선언하는 것이 낫다.
- 객체 간 조합이 필요할 경우 객체 전개 연산자 `...` 를 사용하는 것이 낫다.
- 조건부 속성 다루기

```tsx
declare let hasMiddle: boolean;
const firstLast = {first: 'Harry', last; 'Truman'};
const president = {...firstLast, ...(hasMiddle ? {middle: 'S'} : {})};

const president: {
	middle?: string;
	first: string;
	last: string;
}
```

# 아이템 24. 일관성 있는 별칭 사용하기

- 객체에 별칭을 사용하는 것은 여러 고려가 필요하다.
- 비구조화 할당을 사용하는게 좋다.
- 함수 호출이 실제로는 객체 속성의 타입을 변경할 여지가 있으나 타입스크립트는 그렇지 않다고 가정하기 때문에 속성보다 지역 변수를 사용하는 것이 좋다.

# 아이템 25. 비동기 코드에는 콜백 대신 async 함수 사용하기

> **콜백보다는 프로미스가 타입을 추론하기 쉽습니다.**

> **그러나 선택의 여지가 있다면 일반적으로는 프로미스를 생성하기보다는 async/await를 사용해야 합니다.**

- 더 간결하고 직관적인 코드
- async함수는 항상 프로미스를 반환하도록 강제
  - 프로미스를 반환해도 Promise<something> 형태, 그러지 않아도 자동으로 Promise<something> 형태로 반환하므로 타입 시스템에 적합
- 한 함수 내에서 비동기와 동기를 섞어 사용하면 안됨.

# 아이템 26. 타입 추론에 문맥이 어떻게 사용되는지 이해하기

- let, const 사용 시 주의
- 튜플 사용 시 주의점
  - 타입 좁히기가 필요
  - `as const` 와 `readonly` 를 통해 해결할 수도 있지만 문제가 선언부가 아닌 호출부에서 발생해 디버깅이 어려워질 수 있음.
- 객체 사용 시 주의점
  - `as const` 사용, 타입 선언 추가
- 콜백 사용 시 주의점
  - 상수화 한 콜백을 사용할 경우 문제가 생길 수 있다.
  - 선언부에서 타입 구문을 추가하자

# 아이템 27. 함수형 기법과 라이브러리로 타입 흐름 유지하기

> **같은 코드를 타입스크립트로 작성하면 서드파티 라이브러리를 사용하는 것이 무조건 유리합니다. 타입 정보를 참고하여 작업할 수 있기 때문에 서드파티 라이브러리 기반으로 바꾸는 데 시간이 훨씬 단축됩니다.**

- 최근 추가된 함수형 기법이나 서드파티 라이브러리를 사용하면 메서드 체이닝을 통한 타입의 유지나 타입 정보를 포함하고 있기 때문에 더 간결하고 정확한 타입 추론이 가능하다.
