🔗 [노션 링크](https://artistic-roadrunner-94f.notion.site/TS-7-77cfa31e1d654b4591002bca074c2d6e?pvs=4)

# 📜 7장. 코드를 작성하고 실행하기

“7장에서는 타입과 관계는 없지만 코드를 작성하고 실행하면서 실제로 겪을 수 있는 문제들을 다룹니다.”

## 아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

“TC39는 런타임 기능을 발전시키고, 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지켜오고 있습니다.”

“이 원칙이 세워지기 전에, 이미 사용되고 있던 ( … 중략 ) 기능들은 타입 공간(타입스크립트)과 값 공간(자바스크립트)의 경계를 혼란스럽게 만들기 때문에 사용하지 않는 것이 좋습니다.”

### 열거형(enum)

- 🚨 숫자 열거형에 인덱스 외의 숫자가 할당되면 매우 위험하다.
- 🚨 상수 열거형은 런타임에 완전히 제거된다.
  - `preserveConstEnums` 플래그를 설정했다면 정보를 유지할 수 있다.
- 🚨 문자열 열거형은 런타임의 타입 안전성과 투명성을 제공하지만, 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.
  - 구조적 타이핑은 구조가 같으면 할당이 허용되는 반면, 명목적 타이핑은 **타입의 이름이 같아야 할당이 허용**된다.
- ✨ 자바스크립트와 타입스크립트가 서로 호환되는 리터럴 타입의 유니온을 사용하자!
  - 자동완성 기능도 사용할 수 있다.

### 매개변수 속성

```tsx
class Person {
  constructor(public name: string) {}
}

// 아래 자바스크립트 코드와 동작이 같다.
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
}
```

- 타입스크립트는 매개변수 속성이라는 더 간결한 문법을 제공한다.
  - 🚨 일반적으로 런타임 때 코드가 짧아져야 하지만, 매개변수 속성은 코드가 늘어난다.
  - 🚨 타입스크립트 관점에서는 매개변수 속성이 사용되는 건지 알 수 없다.
  - 🚨 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스 설계가 혼란스러워진다.
- ✨ 클래스에 매개변수 속성만 존재한다면 클래스 대신 인터페이스로 만들고 객체 리터럴을 사용하는 게 좋다.
  - 이왕 매개변수 속성을 사용할 거면 일관성 있게 작성하자!

### 네임스페이스와 트리플 슬래시 임포트

- ECMAScript 2015 이전에는 공식적인 모듈 시스템이 없어서 각 환경마다 다른 방식으로 구현되어 있었다.
  - `Node.js`는 `require`와 `module.exports`, `AMD`는 `define` 함수와 콜백 사용
  - 타입스크립트 역시 `module` 키워드와 `트리플 슬래시` 임포트 사용
- 이후에는 `module`과 같은 기능을 하는 `namespace` 키워드를 추가했다.
  ```tsx
  // 이런 것들이 있다.
  namespace foo {
    function bar() {}
  }

  /// <reference path="other.ts"/>
  foo.bar()
  ```
  - **아무튼 사용하지 마셈**

### 데코레이터

[Documentation - Decorators](https://www.typescriptlang.org/ko/docs/handbook/decorators.html)

- 클래스, 메서드, 속성에 애너테이션을 붙이거나 기능을 추가하는 데 사용할 수 있다.
- `tsconfig.json`에 `experimentalDecorators` 속성을 설정해야 한다.
- 실험적 기능이라고 나와있다.

요약: 타입스크립트만이 가지고 있는 기능을 사용하지 말자.

---

## 아이템 54 객체를 순회하는 노하우

### 객체 순회 오류

```tsx
const obj = {
  one: 'uno',
  two: 'dos',
  three: 'tres',
}
for (const k in obj) {
  const v = obj[k]
  // ~~~~~~ 'string' 형식의 식을 '{ one: string; two: string; three: string; }'
  //        인덱스 형식에 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다.
}
```

- 🚨 `k`의 타입은 `string`인 반면, `obj` 객체에는 `one` `two` `three` 세 개의 키만 존재한다.
- 🚨 `obj` 타입에 할당 가능한 객체에는 `one` `two` `three` 외에 다른 속성이 존재할 수 있기 때문에, 타입스크립트는 `obj` 타입의 키를 `string` 타입으로 선택할 수밖에 없다.
- ✨ `k`의 타입을 구체적으로 `keyof typeof obj`로 명시해주면 오류는 사라진다.

```tsx
const obj = {
  one: 'uno',
  two: 'dos',
  three: 'tres',
}

let k: keyof typeof obj // Type is "one" | "two" | "three"

for (k in obj) {
  const v = obj[k] // OK
}
```

- 🚨 `keyof` 키워드도 또 다른 문제점을 내포하고 있다.
  - 아예 리터럴 타입으로 한정될 수 있는 것이다.
  - 근데 `keyof typeof 객체`는 또 해결 되는데 …
  - 모두 `v`의 타입이 `string | number`가 되어버린다.
  ```tsx
  const x = { a: 'a', b: 'b', c: 2, d: new Date() }
  foo(x) // OK
  ```
- `Object.entries`를 사용하는 방법도 있다.
  ```tsx
  interface ABC {
    a: string
    b: string
    c: number
  }
  function foo(abc: ABC) {
    for (const [k, v] of Object.entries(abc)) {
      k // Type is string
      v // Type is any
    }
  }
  ```
  - 그러나 타입을 다루기 더 까다롭다.

요약: 위의 내용 잘 알아두자.

---

## 아이템 55 DOM 계층 구조 이해하기

“타입스크립트에서는 DOM 엘리먼트의 계층 구조를 파악하기 용이합니다.”

- `EventTarget`: DOM 타입 중 가장 추상화된 타입. 이벤트 리스너 추가, 제거, 전송밖에 못함
- `Node`: 태그 외 정보들도 포함
- `Element`: `<html>`은 `HTMLHtmlElement`이고, `<svg>`는 `SVGSvgElement`이다.
- `HTML....Element`: 각각 자신만의 고유한 속성을 가지고 있다.
  - `HTMLImageElement`: `src`
  - `HTMLInputElement`: `value`
- 보통 태그의 타입은 DOM을 불러오는 메서드를 통해 추론된다.

  - 이때 이미 알고있는 DOM이라면 에러 발생 시 타입 단언을 사용해도 좋음.

- `Event`의 경우에도 각각 이벤트에 다양한 속성이 있기 때문에 알아두면 좋다.

요약: DOM 타입은 타입스크립트에서 중요하다. 각 계층에 대한 차이점을 알아야 한다.

---

## 아이템 56 정보를 감추는 목적으로 private 사용하지 않기

- `public` `protected` `private` 접근 제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거된다.
  - 🚨 따라서 `private`를 사용한다 해서 런타임에서 접근하지 못하는 것은 아니다.
- ✨ 정보를 숨기기 위해서는 **클로저**를 사용해야 한다.
  - 🚨 하지만 정보에 접근하는 메서드 또한 생성자 내부에서 작성해야 하므로 메모리 낭비 문제가 발생한다.
- ✨ `#` 키워드를 통해 캡슐화를 할 수 있다.

---

## 아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기

“타입스트립트 코드를 실행한다는 것은, 엄밀히 말하자면 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행한다는 것입니다.”

- 디버깅 시 보게되는 코드는 전처리기, 컴파일러, 압축기를 거친 자바스크립트 코드다.
  - 🚨 변환된 자바스크립트 코드로 디버깅하기 매우 어렵다.
- ✨ 브라우저 제조사들은 협력해서 **소스맵**이라는 해결책을 내놓았다.

### 소스맵

- 타입스크립트가 소스맵을 생성할 수 있도록 설정할 수 있다.

  ```json
  {
    "compilerOptions": {
      "sourceMap": true
    }
  }
  ```

  - 컴파일을 실행하면 `.js`와 `.js.map` 파일을 생성한다.
  - **`.js.map` 파일이 바로 소스맵이다.**
  - 디버거 좌측의 파일 목록에서 소스맵은 이탤릭체로 표시된다. ⇒ 실제 파일이 아니라는 뜻

- 번들러나 압축기를 사용하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성한다.
  - 번들러가 기본적으로 타입스크립트를 지원하고 있지 않다면 소스맵을 인식할 수 있도록 별도의 설정이 필요하다.
- 상용 환경에 소스맵이 유출되는 것을 조심해야 한다.
- `NodeJS` 프로그램의 디버깅에도 소스맵을 사용할 수 있다.

요약: 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅하자.
