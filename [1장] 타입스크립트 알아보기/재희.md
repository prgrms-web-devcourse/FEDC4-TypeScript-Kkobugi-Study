# 아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기

> **“타입스크립트는 자바스크립트의 상위 집합(superset)이다”**

- 타입스크립트는 런타임에서 실행되지도, 컴파일의 대상이 되지도 않는 언어이다.
- 타입스크립트는 정적 타입의 언어로써 자바스크립트에 안정성을 제공하고, 부가 기능을 제공한다.
- 모든 자바스크립트 프로그램은 타입스크립트 프로그램으로써 작용할 수 있지만, 반대는 성립하지 않는다.

> **타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것입니다.**

- 타입스크립트 타입 체커는 추가적인 타입 구문 없이도 오류를 찾아낸다. 초깃값으로 부터 타입을 추론한다.
- 하지만, 타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있다.
  - 타입스크립트가 제대로 추론할 수 있도록 힌트를 던져주는 것과 같다.

> **타입 스크립트 타입 시스템은 자바스크립트의 런타임 동작을 ‘모델링’한다.**

- 하지만 프로그램의 문제를 사전에 방지하기 위해 다른 대처를 한다.
  - 런타임에서 오류가 발생하지 않더라도 타입 체커가 오류를 표시하는 경우
  - 타입 체크를 통과하더라도 여전히 런타임에 오류가 발생하는 경우
- 타입 시스템은 정적 타입의 정확성을 무조건 보장해주는 목적이 아니다.

# 아이템 2. 타입스크립트 설정 이해하기

> **타입스크립트는 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느껴질 수 있습니다.**

- `noImplicitAny`
  - 암시적 any의 사용을 제한한다.
  - 명시적으로 `:any` 를 사용하면 된다. `any` 의 사용은 최소화하는 것이 좋다.
- `strictNullChecks`
  - null과 undefined가 모든 타입에서 허용되는지 설정한다.
- `strict` 를 설정해 대부분의 오류를 잡아낼 수 있다.

# 아이템 3. 코드 생성과 타입이 관계없음을 이해하기

> **타입스크립트 컴파일러는 두 가지 역할을 수행합니다.**

- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
- 코드의 타입 오류를 체크한다.

→ 이 두 가지 역할은 서로 완벽히 독립적이다.

> **문제가 될 만한 부분을 알려 주지만, 그렇다고 빌드를 멈추지는 않습니다.**

- 작성한 타입스크립트가 유효한 자바스크립트라면 타입스크립트 컴파일러는 컴파일은 진행한다.
- `tsconfig.json` 에 `noEmitOnError` 옵션을 설정하면 오류가 있을 때 컴파일하지 않도록 할 수 있다.

> **런타임에는 타입 체크가 불가능합니다.**

- 타입스크립트 구문은 빌드에서 제거된다.
- 타입 정보를 런타임에서도 명확히 하려면,
  - `in` 키워드 등을 활용하여 특정 속성이 존재하는지 체크
  - 명시적으로 타입을 구분해주는 속성, 프로퍼티를 지정하여 사용 - tagged union 등
- 클래스를 사용하면 타입(런타임 접근 불가)와 값(런타임 접근 가능)을 둘 다 사용 가능하다.
  - `인스턴스명 instanceof 클래스명` 으로 확인 가능

> **타입 연산은 런타임에 영향을 주지 않습니다.**

- `as number` 나 `:number` 등으로 런타임에서 특정 값을 정제하거나 할 수 없다.
- 런타임에서 목적에 따라 사용할 자료형 관련 처리 등을 타입 체크를 위한 코드와 혼동해서 사용하면 의도치 않은 결과를 초래할 수 있다.

> **런타임 타입은 선언된 타입과 다를 수 있습니다.**

- 타입스크립트의 목적은 코드의 설계가 런타임에서 문제를 일으킬 수 있는 경우를 최대한 방지하는 목적이지, 런타임에서의 타입을 강제하거나 확인하는 데에 있지 않다.
- 그러므로 런타임에서는 다른 값이 입력될 수 있음을 명심해야한다.

> **타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.**

- ‘런타임’ 오버헤드가 없는 대신, ‘빌드타임’ 오버헤드가 있다.
- 빌드 도구를 통해 트랜스파일만 하도록 설정할 수도 있다.
- 호환성을 위해 특정 헬퍼 코드를 추가하느라 성능 오버헤드를 감수해야 할 수도 있다.

# 아이템 4. 구조적 타이핑에 익숙해지기

> **자바스크립트는 본질적으로 덕 타이핑(duck typing) 기반입니다.**

- 타입스크립트 또한 이를 그대로 모델링한다.
- 호환되는 구조에 대해 타입 에러 없이 사용이 된다.

> **구조적 타이핑 때문에 문제가 발생하기도 합니다.**

- 의도와 다르게 작성된 코드에 대해 타입 시스템이 문제를 감지하지 못 할 수 있다.
- 예를 들어 인자의 요소 중 하나를 사용하는 것을 누락했을 때, 타입 시스템은 그 자체에 대해서만 확인할 뿐이다.
  - 왜냐면 타입스크립트의 타입 시스템은 기본적으로 ‘열려(open)’있기 때문이다.
  - `a, b`를 요구하는 함수에 대해서 `a, b, c, d` 가 들어있는 데이터를 넘기든, `a, b, x` 가 들어있는 데이터를 넘기는 문제로 인식할 수 없다.
- 하지만 타입 시스템은 스스로 열려있다는 인식을 기반으로 추론을 한다.
  - 때문에 우리도 타입 시스템처럼 생각할 수 있어야한다.
  - 예를 들어 전달 받은 객체를 순회하여 사용할 때, 아래와 같은 상황이 발생한다.
  ```tsx
  // 봉인된, 닫혀있는 타입 시스템을 생각하고 만든 코드
  function calculate(v: {x: number, y:number}): number{
      let sum = 0
  	for(const key of Object.keys(v)){
  		sum += v[key]
  	}
      return sum
  }

  -> error
  // v는 x, y 외에 어떤 프로퍼티든 가질 수 있기 때문에, 'string' 타입이 v에 입력될 수 있다는 에러가 나온다.

  // 단순히 에러를 처리해 준 코드
  function calculate(v: { [x: string]: number; y: number }): number {
    let sum = 0
    for (const key of Object.keys(v)) {
      sum += v[key]
    }

    return sum
  }

  -> no error but not good
  // 'string' 인덱스 시그니처를 추가해주어 x, y 외에 속성이 string 키의 number 값일 것임을 이해시킨다.
  // 하지만 설계 의도(x와 y만 사용하는 목적)과는 다른 결과를 불러올 수 있다.

  // 열려있는 타입 시스템에 의도를 명확히는 코드
  function calculate(v: {x: number, y:number}): number{
      let sum = 0
      sum += v.x + v.y

      return sum
  }

  -> good
  // 명확히 사용할 내용을 나타내주어 타입에서나 런타임에서나 문제 소지를 줄일 수 있다.
  ```
- 또한 생성자의 결과와 단순히 같은 구조를 가진 변수가 구조적 타이핑을 거치므로 같은 클래스 타입으로 할당하는데 에러가 발생하지 않는 주의점이 있다.

# 아이템 5. any 타입 지양하기

> **일부 특별한 경우를 제외하고는 any를 사용하면 타입스크립트의 수많은 장점을 누릴 수 없게 됩니다.**

- any를 할당하면 타입 안정성을 더욱 보장할 수 없다.
- 함수 인자로 전달할 때 파라미터의 타입 선언을 무시한다.
- 타입 서비스가 제공하는 자동완성 기능과 도움말 등이 적용되지 않는다.
- 리팩토링 시 타입체크가 동작하지 않으므로 예상치 못한 버그가 발생해도 알 수 없다.
- 타입 설계를 감추기 때문에 일일이 확인해야한다.
