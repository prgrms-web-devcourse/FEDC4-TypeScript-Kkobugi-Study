🔗 [노션 링크](https://artistic-roadrunner-94f.notion.site/TS-2-d2af1396939943f88394b9e0183e202b?pvs=4)

# 📜 2장. 타입스크립트의 타입 시스템

2장에서는 타입 시스템의 기초부터 살펴본다.

- 타입 시스템은 무엇일까?
- 어떻게 사용해야 할까?
- 무엇을 결정해야 할까?
- 가급적 사용하지 말아야 할 기능은 무엇일까?

---

## ✶ 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

타입 스크립트에서는 두 가지를 실행할 수 있다.

- **타입스크립트 컴파일러(tsc)**
- **단독으로 실행할 수 있는 타입스크립트 서버(tsserver)**

**타입스크립트 서버** 또한 **‘언어 서비스’**를 제공한다.

### 언어 서비스가 하는 일

- 코드 자동 완성
- 명세 검사
- 검색
- 리팩터링

### 타입스크립트 언어 서비스의 장점

- 코드 작성 편함
- 타입 추론 개념을 잡기 유용함

  ```tsx
  function getElement(elOrId: string | HTMLElement | null): HTMLElement {
    if (elOrId === null) {
      return document.body
    } else if (typeof elOrId === 'object') {
      return elOrId
    } else {
      const el = document.getElementById(elOrId)!
      return el
    }
  }

  export default {}
  ```

  - null을 먼저 잡음
  - Non-null assertion operator 사용

- 라이브러리 타입을 탐색할 때 도움이 됨
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56b3a7a5-6499-4832-b165-dff5f2ca9c11/Untitled.png)

---

## ✶ 아이템 7 타입이 값들의 집합이라고 생각하기

모든 변수는 런타임에 고유한 값을 가진다.

그러나 런타임 이전에는 **‘타입’**을 가지고 있다.

### 타입 == ‘할당 가능한 값들의 집합’

- 가장 작은 집합은 유닛 타입이라고도 불리는 리터럴 타입
  `type A = ‘A’`

### 타입 연산자는 값의 집합(타입의 범위)에 적용된다

```tsx
interface Identified {
  id: string
}
interface Person {
  name: string
}
interface Lifespan {
  birth: Date
  death?: Date
}
type PersonSpan = Person & Lifespan
const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
} // OK
```

`keyof (A & B) = (keyof A) | (keyof B)
 keyof (A | B) = (keyof A) & (keyof B)`

- A와 B의 인터섹션은 **A & B인 값이 A와 B의 속성을 모두 가짐**을 의미한다.

### extends 키워드는 ‘~의 부분집합’

```tsx
function getKey<K extends string>(val: any, key: K) {
  // ...
}
getKey({}, 'x') // OK, 'x' extends string
getKey({}, Math.random() < 0.5 ? 'a' : 'b') // OK, 'a'|'b' extends string
getKey({}, document.title) // OK, string extends string
getKey({}, 12)
// ~~ Type '12' is not assignable to parameter of type 'string'

export default {}
```

- ‘A는 B를 상속’, ‘A는 B에 할당 가능’, ‘A는 B의 서브타입’은 **‘A는 B의 부분집합’**이라는 뜻

---

## ✶ 아이템 8 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌(symbol)은 타입 공간, 값 공간 중 한 곳에 존재한다.

```tsx
interface Cylinder {
  radius: number
  height: number
}

const Cylinder = (radius: number, height: number) => ({ radius, height })
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
    // ~~~~~~ Property 'radius' does not exist on type '{}'
  }
}
```

- 타입에서의 Cylinder와 값에서의 Cylinder가 있다.
- instanceof는 js의 런타임 연산자이므로 값인 함수를 참조한다.

두 공간에 대한 값을 잡으려면 플레이그라운드 사이트를 통해 TS → JS 코드를 살펴보자!

### class와 enum은 타입과 값 둘 다 가능하다

```tsx
interface Person {
  first: string
  last: string
}
const p: Person = { first: 'Jane', last: 'Jacobs' }
//    -           --------------------------------- Values
//       ------ Type
function email(p: Person, subject: string, body: string): Response {
  //     ----- -          -------          ----  Values
  //              ------           ------        ------   -------- Types
  // COMPRESS
  return new Response()
  // END
}

class Cylinder {
  radius = 1
  height = 1
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape // OK, type is Cylinder
    shape.radius // OK, type is number
  }
}
const v = typeof Cylinder // Value is "function"
type T = typeof Cylinder // Type is typeof Cylinder
type C = InstanceType<typeof Cylinder> // Type is Cylinder (생성자, 인스턴스 타입 전환)
type PersonEl = Person['first' | 'last'] // Type is string
type Tuple = [string, number, Date]
type TupleEl = Tuple[number] // Type is string | number | Date (number가 0, 1, 2 중에 하나만 올 수 있으니까)

export default {}
```

- `typeof`는 타입과 값에서 쓰일 때 다른 기능을 한다.
- `Cylinder`는 인스턴스의 타입이 아니다.
- type이 `typeof Cylinder`와 `Cylinder`는 다르다.
- 객체 속성의 type에 접근할 때는 대괄호 표기법으로만 접근할 수 있다.

### 구조 분해 할당에 타입 적용하기

```tsx
interface Person {
  first: string
  last: string
}
function email({
  person,
  subject,
  body,
}: {
  person: Person
  subject: string
  body: string
}) {
  // ...
}
```

- 값의 관점에서 Person과 string이 해석될 수 있다.
- 타입과 값을 구분해야 잘 인식한다.

---

## ✶ 아이템 9 타입 단언보다는 타입 선언을 사용하기

```tsx
interface Person {
	name: string
}

const alice: Person = { name: 'Alice' } // 너는 Person이어야 하고 만약 아니면 오류를 낼 거야!
const bob = {} as Person // Type is Person 뭐든간에 객체면 난 Person으로 보겠다! 단언

const 11 = {} as Person // 이건 또 에러
const [] = {} as Person // 이건 또 에러
```

- 타입 단언은 타입 체커에게 오류를 무시하라고 하는 것과 같다.

### 화살표 함수

```tsx
interface Person {
  name: string
}
const people = ['alice', 'bob', 'jan'].map((name) => ({} as Person))
// No error
```

- 타입 체크 때는 에러가 발생하지 않는다.
- 런타임에서 문제가 발생할 수 있다.

```tsx
interface Person {
  name: string
}
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({ name })
)

// ===

interface Person {
  name: string
}
const people: Person[] = ['alice', 'bob', 'jan'].map((name) => ({ name }))

// ===

interface Person {
  name: string
}
const people = ['alice', 'bob', 'jan'].map<Person>((name) => ({ name })) // 컴포넌트 태그로 인식될 수 있으므로 지양
```

- 첫 번째 예시가 가독성 측면에서 더 좋다.
- `(name: Person)` 과 `(name): Person` 은 다르다.
  ⇒ 전자는 매개변수가 Person 타입. 후자는 반환값 타입이 Person.

- DOM에서는 단언문을 사용하는 것이 낫다.
  ⇒ 타입 체커보다 우리가 추론한 타입이 정확할 수 있기 때문에.
- 그러나 단언문은 **단언하는 타입이 서브 타입**일 경우에만 가능하다.

---

## ✶ 아이템 10 객체 래퍼 타입 피하기

`undefined`, `null`을 제외한 모든 원시값들은 객체 래퍼 타입이 존재한다.

자바스크립트는 기본형과 객체 타입을 자유롭게 변환한다.

```tsx
const a = 'hello'

a.substring(0, 1)
```

```tsx
const a: String | string = new String() // 이거로 이해
const b: String = 'hi'
const c: string = new String() // 에러
```

- 객체 래퍼로 타입을 지정하지 말자.
- 그러나 Symbol, BigInt는 기본형을 생성하기 때문에 사용해도 OK.
- 그래도 기본형으로 사용하자 ..

---

## ✶ 아이템 11 잉여 속성 체크의 한계 인지하기

- 잉여 속성 체크는 객체 리터럴일 때만 가능하다.
- 잉여 속성 체크와 할당 가능 검사는 별도의 과정이다.
- 타입 단언문을 사용할 때도 적용되지 않는다.
- 인덱스 시그니처를 통해서 추가적인 속성을 미리 알려줘도 된다.
  `[otherOptions: string]: unknown`

```tsx
interface Room {
  numDoors: number
  ceilingHeightFt: number
}
function setDarkMode() {}
interface Options {
  title: string
  darkMode?: boolean
}
const intermediate = { darkmode: true, title: 'Ski Free' }
const o: Options = intermediate // OK
const o2 = { darkmode: true, title: 'Ski Free' } as Options // OK
```

<aside>
🤔 **잉여 속성 체크와 구조적 할당 가능성 체크의 차이점**

`잉여 속성 체크`는 객체 리터럴을 인터페이스에 할당할 때 인터페이스에 정의되지 않은 추가 속성을 방지하는 반면,

`구조적 할당 가능성 체크`는 객체나 인터페이스의 구조적 호환성을 검사하여 할당 가능성을 판단합니다.

</aside>
