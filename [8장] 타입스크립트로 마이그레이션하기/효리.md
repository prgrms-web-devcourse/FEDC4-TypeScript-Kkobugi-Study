🔗 [노션 링크](https://artistic-roadrunner-94f.notion.site/TS-8-da2531d2784d4705ba65ba5514aa65fb?pvs=4)

# 📜 8장. 타입스크립트로 마이그레이션하기

“마이그레이션이 얼마나 진행되었고 현재 상황이 어떤지 수치화하여 눈으로 볼 수 있게 하면 팀원들에게 동기 부여도 될 겁니다.”

- 타입스크립트를 사용하면 자바스크립트 프로젝트의 버그를 방지할 수 있다.
- 8장의 예제는 순수 자바스크립트이므로 `noImplicitAny`를 `off`로 설정해놓자!

## 아이템 58 모던 자바스크립트로 작성하기

“타입스크립트를 도입할 때 가장 중요한 기능은 ECMAScript 모듈과 ES2015 클래스입니다.”

- 타입스크립트로 1999년에 나온 ES3버전의 자바스크립트 코드로도 컴파일할 수 있다.
  - 타입스크립트 컴파일러를 자바스크립트 ‘트랜스파일러’로 사용할 수 있다.
  - 따라서 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업부터 시작하는 것이 좋다.
  - 옛날 JS 플젝 → TS를 통해 최신 JS로 컴파일하기
- 자바스크립트가 단일 파일이거나 비표준 모듈 시스템이라면 ES 모듈로 전환하는 것이 좋다.
- 프로토타입을 사용했다면 클래스 기반 객체로 바꾸는 것이 좋다.
  - 편집기에서 프로토타입 객체에 마우스를 올려 `함수를 ES2015 클래스로 변환`을 선택하면 간단하게 변환할 수 있다.
- `var`를 `let`과 `const`로 바꿔야 한다.
- C 스타일의 `for(;;)` 대신 `for-of` 또는 배열 메서드를 사용하는 것이 좋다.
  - `for-in` 문은 지양하는 게 좋다.
- 함수 표현식보다 화살표 함수를 사용하는 것이 좋다.
  - `this`와 관련된 문제를 해결하기 위해서다.
  - `noImplicitThis`를 설정하면 `this` 관련한 오류를 표시해주므로 설정하는 것이 좋다.
- 단축 객체 표현과 구조 분해 할당을 사용하자.

  ```tsx
  const x = 1,
    y = 2,
    z = 3
  const pt = { x, y, z }

  // 객체에서는 메서드 형태로 만들자 ~
  const obj = {
    onClickCompact(e) {
      // ...
    },
  }

  // 구조 분해 할당을 하자 ~
  const { props } = obj
  const { a, b } = props

  // 기본값을 지정할 수도 있다.
  const { a = 'default' } = obj.props
  ```

- 함수 매개변수의 기본값을 사용하자.
  - 지정하지 않으면 `undefined`로 간주된다.
- 저수준 프로미스나 콜백 보다는 `async/await`을 사용하자!
- 인덱스 시그니처는 문제가 있다.

  ```tsx
  function countWords(text: stirng) {
    const counts: { [word: stirng]: number } = {}
    for (const word of text.split(/[\s,.]+/)) {
      counts[word] = 1 + (counts[word] || 0)
    }
    return counts
  }

  // 예상치 못한 결과가 나옴
  console.log(countWords('Objects have a constructor'))
  ```

  - `'constructor'`라는 특정 문자열이 주어지면 문제가 발생한다.
  - 🚨 왜냐하면 `cunstructor`의 초기값은 `undefined`가 아닌 생성자 함수가 바인딩 된 값이기 때문이다.
    - ✨ `Map`을 사용하는 게 좋다.

  ```tsx
  function countWords(text: stirng) {
  	const counts: new Map<string, number>();
  	for (const word of text.split(/[\s,.]+/)) {
  		counts.set(word, 1 + (counts.get(word) || 0));
  	}
  	return counts;
  }
  ```

- 타입스크립트에 `use strict`를 넣지 말아야 한다.
  - 타입스크립트의 안전성 검사가 엄격 모드보다 훨씬 더 엄격한 체크를 한다.
- TC39의 깃허브 저장소와 타입스크립트의 릴리스 노트를 통해 최신 기능을 확인하자!

---

## 아이템 59 타입스크립트 도입 전에 `@ts-check`와 `JSDoc`으로 시험해 보기

### `@ts-check`

- `noImplicitAny` 설정을 해제한 것보다 훨씬 느슨한 타입 체크를 한다.
  - 선언되지 않는 전역 변수를 체크한다. (⇒ 타입스크립트로 변환할 때는 타입 선언 파일을 만들면 된다.)
  - 알 수 없는 라이브러리를 체크한다. (⇒ 제이쿼리 타입 선언을 설치한다.)
  - DOM 문제를 체크한다.
  - 부정확한 `JSDoc`을 체크한다.

요약: 자바스크립트 환경에서도 `@ts-check`와 `JSDoc` 주석으로 타입스크립트와 비슷하게 작업이 가능하다. 하지만 최종 목표는 모든 코드가 타입스크립트로 전환되는 것임을 잊지 말아야 한다.

즉, 이미 `JSDoc` 주석이 많이 있을 경우에만 `@ts-check`를 간단히 추가함으로써 타입 체커를 실험하면 된다.

---

## 아이템 60 `allowJs`로 타입스크립트와 자바스크립트 같이 사용하기

“대규모 프로젝트는 한꺼번에 작업하는 것이 불가능하므로 점진적으로 전환할 수 있어야 합니다. 그러려면 마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야 합니다.”

- `allowJs` 컴파일러 옵션은 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다.
- 번들러에 타입스크립트가 통합되어 있거나, 플러그인 방식으로 통합이 가능하다면 `allowJs`를 간단히 적용할 수 있다.
- 대규모 마이그레이션 작업을 시작하기 전에, 테스트와 빌드 체인에 타입스크립트를 적용해야 한다.

---

## 아이템 61 의존성 관계에 따라 모듈 단위로 전환하기

“의존성과 관련된 오류 없이 작업하려면, 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 합니다.”

- 서드파티 라이브러리 타입을 가장 먼저 해결해야 한다.
  - `@types` 모듈을 설치하면 된다.
- 이후 외부 API의 타입 정보를 추가한다.
- 모듈 단위로 마이그레이션을 시작하기 전에, 모듈 간의 의존성 관계를 시각화하면 좋다.
- 마이그레이션할 때는 타입 정보 추가만 하고 리팩토링을 해서는 안 된다.
  - 타입스크립트 전환부터 하자!
- 테스트 코드는 항상 의존성 관계도의 최상단에 위치하기 때문에 마이그레이션 기간에도 테스트를 수행할 수 있다.

### 타입스크립트 전환 시 또 다른 오류

- 타입스크립트에서는 클래스 멤버 변수를 명시적으로 선언해야 한다. (빠른 수정 기능으로 해결 가능), 빠른 수정 후에 타입을 다시 수정해줘야 한다.
- 객체는 한꺼번에 생성하지 않으면 오류가 난다.
  - 한꺼번에 생성하게 변경 or 타입 단언문

---

## 아이템 62 마이그레이션의 완성을 위해 `noImplicitAny` 설정하기

- 프로젝트 전체를 `.ts`로 전환했다면, 마지막 단계인 `noImplicitAny`을 설정하도록 하자.
- 처음에는 빌드의 실패를 막기 위해 `noImplicitAny`를 로컬에만 설정하고 작업하는 것이 좋다.
- 타입 체크의 강도는 조금씩 높이는 것이 좋다.
  - `strictNullChecks` ⇒ `noImplicitAny` ⇒ `"strict": true`
