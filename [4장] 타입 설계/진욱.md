# **4ì¥ íƒ€ì… ì„¤ê³„**

### **íƒ€ì… ìì²´ì˜ ì„¤ê³„ì— ëŒ€í•´ ë‹¤ë£¹ë‹ˆë‹¤**

### ì–´ë–»ê²Œ íƒ€ì… ì„¤ê³„ë¥¼ ì˜ í•  ê²ƒì´ëƒ..

### ì–´ë–»ê²Œ íƒ€ì… ì´ë¦„ì„ ì˜ ì§€ì„ ê²ƒì´ëƒ

---

## **`ì•„ì´í…œ28` ìœ íš¨í•œ ìƒíƒœë§Œ í‘œí˜„í•˜ëŠ” íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°**

```ts
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
```

### ìœ„ì™€ ê°™ì€ ìƒíƒœê°’ì˜ ë¬¸ì œê°€ ë¬´ì—‡ì¼ê¹Œ?

`isLoading`ì´ `true`ì´ë©´ì„œ ë™ì‹œì— `error`ê°’ì´ ì„¤ì •ë˜ëŠ” ë¬´íš¨í•œ ìƒíƒœë¥¼ í—ˆìš©í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ë¬´íš¨í•œ ìƒíƒœê°€ ì¡´ì¬í•œë‹¤ë©´ ì œëŒ€ë¡œ ëœ êµ¬í˜„ì„ í•  ìˆ˜ ì—†ë‹¤.

ê·¸ëŸ¬ë©´ ìœ„ ì˜ˆì‹œì—ì„œ ì–´ë–»ê²Œ ë¬´íš¨í•œ ìƒíƒœë¥¼ ì—†ì•¨ ìˆ˜ ìˆì„ê¹Œ?

```ts
interface RequestPending {
  state: 'pending';
}
interface RequestError {
  state: 'error';
  error: string;
}
interface RequestSuccess {
  state: 'ok';
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;
```

ìš”ì²­ ìƒíƒœë¥¼ ë” ëª…ì‹œì ìœ¼ë¡œ ëª¨ë¸ë§í•˜ëŠ” íƒœê·¸ëœ ìœ ë‹ˆì˜¨ì´ ì‚¬ìš©ë˜ì—ˆë‹¤.

íƒ€ì… ì½”ë“œì˜ ê¸¸ì´ê°€ ê¸¸ì–´ì§€ê¸´ í–ˆì§€ë§Œ ë¬´íš¨í•œ ìƒíƒœë¥¼ í—ˆìš©í•˜ì§€ ì•Šë„ë¡ ê°œì„ ëœ ëª¨ìŠµì´ë‹¤.

### ê²°ë¡ 

íƒ€ì…ì„ ì„¤ê³„í•  ë•Œ ì–´ë–¤ ê°’ë“¤ì„ í¬í•¨í•˜ê³  ì œì™¸í• ì§€ ì‹ ì¤‘íˆ ìƒê°í•˜ì

ìœ íš¨í•œ ìƒíƒœë§Œ í‘œí˜„í•œë‹¤ë©´ ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ì‰¬ì›Œì§€ê³  íƒ€ì…ì²´í¬ê°€ ì‰¬ì›Œì§„ë‹¤

---

## **`ì•„ì´í…œ29` ì‚¬ìš©í•  ë•ŒëŠ” ë„ˆê·¸ëŸ½ê²Œ, ìƒì„±í•  ë•ŒëŠ” ì—„ê²©í•˜ê²Œ**

> ë‹¹ì‹ ì˜ ì‘ì—…ì€ ì—„ê²©í•˜ê²Œ í•˜ê³ , ë‹¤ë¥¸ ì‚¬ëŒì˜ ì‘ì—…ì€ ë„ˆê·¸ëŸ½ê²Œ ë°›ì•„ë“¤ì—¬ì•¼ í•œë‹¤.

í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì—ë„ ë¹„ìŠ·í•œ ê·œì¹™ì„ ì ìš©í•˜ì.

í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ëŠ” íƒ€ì…ì˜ ë²”ìœ„ê°€ ë„“ì–´ë„ ë˜ì§€ë§Œ, ë°˜í™˜ íƒ€ì…ì€ êµ¬ì²´ì ì´ì–´ì•¼ í•œë‹¤.

```ts
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}

type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];

type LngLatBounds =
  | { northeast: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;

declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;

type Feature = any;

declare function calculateBoundingBox(
  f: Feature
): [number, number, number, number];

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    //        ~~~      Property 'lat' does not exist on type ...
    //             ~~~ Property 'lng' does not exist on type ...
    zoom,
  } = camera;
  zoom; // Type is number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

ìœ„ ì˜ˆì‹œëŠ” `viewportForBounds` í•¨ìˆ˜ì˜ ë°˜í™˜íƒ€ì…ì´ ë„ˆë¬´ ììœ ë¡œì›Œ ì‚¬ìš©í•˜ê¸° ì–´ë ¤ì›Œì§„ ëª¨ìŠµì´ë‹¤.

ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì˜ ë²”ìœ„ê°€ ë„“ìœ¼ë©´ ì‚¬ìš©í•˜ê¸° í¸ë¦¬í•˜ì§€ë§Œ ë°˜í™˜íƒ€ì…ì˜ ë²”ìœ„ê°€ ë„“ìœ¼ë©´ ë¶ˆí¸í•˜ë‹¤.

ë”°ë¼ì„œ ì‚¬ìš©í•˜ê¸° í¸í•œ APIì¼ìˆ˜ë¡ ë°˜í™˜íƒ€ì…ì´ ì—„ê²©í•´ì•¼ í•œë‹¤.

ìœ„ ì˜ˆì‹œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?

**ì¢Œí‘œë¥¼ ìœ„í•œ ê¸°ë³¸ í˜•ì‹ì„ ë¶„ë¦¬í•˜ëŠ” ë°©ë²•ì´ ìˆë‹¤.**

**`LngLat` ê³¼ `LngLatLike` ë¡œ ë¶„ë¦¬í•´ë³´ì**

```ts
interface LngLat {
  lng: number;
  lat: number;
}
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

`CameraOptions`ì˜ `center`ì†ì„±ì˜ íƒ€ì…ì„ `LngLatLike`ë¡œ ë°”ê¿”ì„œ `setCamera` í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì˜ ë²”ìœ„ë¥¼ ë„“í˜€ì¤€ ëª¨ìŠµì´ë‹¤.

`viewportForBounds` í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ì´ ì—„ê²©í•´ì ¸ ì‚¬ìš©í•˜ê¸° í¸ë¦¬í•´ì¡Œë‹¤.

ì´ ì˜ˆì‹œì—ì„œëŠ” ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì˜ í˜•íƒœë¥¼ 19ê°€ì§€ë‚˜ í˜€ìš©í•œë‹¤. ë§¤ê°œë³€ìˆ˜ ì¹˜ê³ ë„ ë„ˆë¬´ ë„“ì€ ì„¤ê³„ì¼ ìˆ˜ ìˆë‹¤.

í•˜ì§€ë§Œ ë°˜í™˜ íƒ€ì…ì´ 19ê°€ì§€ì¸ ê²ƒì€ ëª…ë°±íˆ ë‚˜ìœ ì„¤ê³„ì´ë‹¤.

---

## **`ì•„ì´í…œ30` ë¬¸ì„œì— íƒ€ì… ì •ë³´ë¥¼ ì“°ì§€ ì•Šê¸°**

### **ì£¼ì„ì€ ì½”ë“œì™€ ë™ê¸°í™”ë˜ì§€ ì•ŠëŠ”ë‹¤.**

### í•¨ìˆ˜ì˜ ì…ì¶œë ¥ì˜ íƒ€ì…ì„ ì½”ë“œë¡œ í‘œí˜„í•˜ëŠ” ê²ƒì´ ì£¼ì„ë³´ë‹¤ ë‚˜ì€ ë°©ë²•ì´ë‹¤.

ë˜í•œ íƒ€ì… êµ¬ë¬¸ì€ ì»´íŒŒì¼ëŸ¬ê°€ ì²´í¬í•´ ì£¼ê¸° ë•Œë¬¸ì— êµ¬í˜„ì²´ì™€ ì •í•©ì„±ì´ ì–´ê¸‹ë‚˜ì§€ ì•ŠëŠ”ë‹¤.

ê°’ì„ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì£¼ì„ë„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.

readonlyë¡œ ì„ ì–¸í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ê°•ì œí•˜ê²Œ í•  ìˆ˜ ìˆë‹¤.

ë³€ìˆ˜ëª…ì—ë„ íƒ€ì… ì •ë³´ë¥¼ ë„£ì§€ ë§ì.(ë‹¨ìœ„ê°€ ìˆëŠ” ê²½ìš°ëŠ” ì˜ˆì™¸ì„)

---

## **`ì•„ì´í…œ31` íƒ€ì… ì£¼ë³€ì— nullê°’ ë°°ì¹˜í•˜ê¸°**

ìˆ«ìë“¤ì˜ ìµœì†Ÿê°’, ìµœëŒ“ê°’ì„ ê³„ì‚°í•˜ëŠ” extentí•¨ìˆ˜

```ts
function extent(nums: number[]) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
      //             ~~~ Argument of type 'number | undefined' is not
      //                 assignable to parameter of type 'number'
    }
  }
  return [min, max];
}
```

ë°˜í™˜ íƒ€ì…ì´ `(number | undefined)[]`ê°€ ë˜ëŠ” ì„¤ê³„ì  ê²°í•¨ì´ ìˆë‹¤.

í•´ë²•ì€?

min, maxë¥¼ í•œ ê°ì²´ ì•ˆì— ë„£ê³  nullì´ê±°ë‚˜ nullì´ ì•„ë‹ˆê²Œ í•˜ë©´ ëœë‹¤.

```ts
function extent(nums: number[]) {
  let result: [number, number] | null = null;
  for (const num of nums) {
    if (!result) {
      result = [num, num];
    } else {
      result = [Math.min(num, result[0]), Math.max(num, result[1])];
    }
  }
  return result;
}

const [min, max] = extent([0, 1, 2])!;
const span = max - min;
```

ë°˜í™˜ íƒ€ì…ì´ `[number, number] | null`ì´ ë˜ì–´ ì‚¬ìš©í•˜ê¸° í¸í•´ì¡Œë‹¤.

**í´ë˜ìŠ¤ì—ì„œ nullê³¼ nullì´ ì•„ë‹Œ ê°’ì„ ì‚¬ìš©í–ˆì„ ë•Œì˜ ë¬¸ì œì **

```ts
interface UserInfo {
  name: string;
}
interface Post {
  post: string;
}

declare function fetchUser(userId: string): Promise<UserInfo>;
declare function fetchPostsForUser(userId: string): Promise<Post[]>;

class UserPosts {
  user: UserInfo | null;
  posts: Post[] | null;

  constructor() {
    this.user = null;
    this.posts = null;
  }

  async init(userId: string) {
    return Promise.all([
      async () => (this.user = await fetchUser(userId)),
      async () => (this.posts = await fetchPostsForUser(userId)),
      // ì†ì„±ê°’ì˜ ë¶ˆí™•ì‹¤ì„±: user, posts ê°€ ê°ê° ë”°ë¡œ null ìƒíƒœì¼ ìˆ˜ ìˆë‹¤.
      // ì´ 4ê°€ì§€ ê²½ìš°ê°€ ì¡´ì¬
      // ì´ëŸ° ë¶ˆí™•ì‹¤ì„±ì€ í´ë˜ìŠ¤ì˜ ëª¨ë“  ë©”ì„œë“œì— ë‚˜ìœ ì˜í–¥(null ì²´í¬ ë‚œë¬´, ë²„ê·¸ ì–‘ì‚°)ì„ ì£¼ê²Œ ëœë‹¤.
    ]);
  }

  getUserName() {
    // ...?
  }
}
```

ë‹¤ìŒê³¼ ê°™ì´ í•„ìš”í•œ ë°ì´í„°ê°€ ëª¨ë‘ ì¤€ë¹„ëœ ë’¤ì— í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ë„ë¡ í•˜ì—¬ ê°œì„ í•  ìˆ˜ ìˆë‹¤.

```ts
class UserPosts {
  user: UserInfo;
  posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }

  static async init(userId: string): Promise<UserPosts> {
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId),
    ]);
    return new UserPosts(user, posts);
  }

  getUserName() {
    return this.user.name;
  }
}
```

nullì¸ ê²½ìš°ê°€ í•„ìš”í•œ ì†ì„±ì€ í”„ë¡œë¯¸ìŠ¤ë¡œ ë°”ê¾¸ë©´ ì•ˆ ëœë‹¤.

í”„ë¡œë¯¸ìŠ¤ëŠ” ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ì½”ë“œë¥¼ ë‹¨ìˆœí•˜ê²Œ ë§Œë“¤ì§€ë§Œ, ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤ì—ì„œëŠ” ì½”ë“œê°€ ë³µì¡í•´ì§€ê¸°ë„ í•œë‹¤.

> ì´ ë¶€ë¶„ì´ ë­”ê°€ ì™€ë‹¿ì§€ê°€ ì•Šë„¤ìš”.

### ìš”ì•½

- í•œ ê°’ì˜ null ì—¬ë¶€ê°€ ë‹¤ë¥¸ ê°’ì— ì•”ì‹œì ìœ¼ë¡œ ê´€ë ¨ë˜ë„ë¡ ì„¤ê³„í•˜ì§€ ë§ì.
  - strictNullChecks ì„¤ì •í•˜ë©´ ì˜¤ë¥˜ê°€ í‘œì‹œë  ê²ƒ. ë”°ë¼ì„œ ì´ ì„¤ì •ì„ ê¼­ í•´ë‘ì
- API ì‘ì„± ì‹œ ë°˜í™˜ íƒ€ì…ì„ í° ê°ì²´ë¡œ ë§Œë“¤ê³  ë°˜í™˜ íƒ€ì… ì „ì²´ê°€ nullì´ê±°ë‚˜ nullì´ ì•„ë‹ˆê²Œ ë§Œë“¤ì–´ì•¼ í•œë‹¤.
- í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ë•Œ ëª¨ë“  ì†ì„±ê°’ì´ ì¤€ë¹„ëì„ ë•Œ ìƒì„±í•˜ì—¬ nullì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.

---

## **`ì•„ì´í…œ32` ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ë³´ë‹¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•˜ê¸°**

### ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ ì˜ˆì‹œ

```ts
interface Layer {
  type: 'fill' | 'line' | 'point';
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

`type: 'fill'`ê³¼ í•¨ê»˜ `LineLayout`ê³¼ `PointPaint`ì´ ì“°ì´ëŠ” ê²ƒì€ ë§ì´ ë˜ì§€ ì•ŠëŠ”ë‹¤. **(ë¬´íš¨í•œ ìƒíƒœ)**

### **ìœ íš¨í•œ ìƒíƒœ**ë§Œì„ í‘œí˜„í•˜ê¸° ìœ„í•´ ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ìœ¼ë¡œ ë°”ê¾¸ê¸°

```ts
interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  type: 'paint';
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

`Layer` íƒ€ì…ì˜ ë²”ìœ„ë¥¼ ì¢í˜”ê³ , íƒœê·¸ëœ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•´ íƒ€ì…ì˜ ë²”ìœ„ë¥¼ ë” ì¢íˆê¸°ë„ ì‰¬ì›Œì¡Œë‹¤.

ì†ì„±ë“¤ê°„ì˜ ê´€ê³„ë¥¼ ì œëŒ€ë¡œ ëª¨ë¸ë§í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì½”ë“œì˜ ì •í™•ì„±ì„ ì²´í¬í•˜ëŠ” ë° ë„ì›€ì´ ëœë‹¤.

```ts
function drawLayer(layer: Layer) {
  if (layer.type === 'fill') {
    const { paint } = layer; // Type is FillPaint
    const { layout } = layer; // Type is FillLayout
  } else if (layer.type === 'line') {
    const { paint } = layer; // Type is LinePaint
    const { layout } = layer; // Type is LineLayout
  } else {
    const { paint } = layer; // Type is PointPaint
    const { layout } = layer; // Type is PointLayout
  }
}
```

### ì—¬ëŸ¬ ê°œì˜ ì„ íƒì  í•„ë“œê°€ ë™ì‹œì— ê°’ì´ ìˆê±°ë‚˜ ë™ì‹œì— `undefined`ì¼ ë•Œ

```ts
// BAD
interface Person {
  name: string;
  // ë‹¤ìŒì€ ë‘˜ ë‹¤ ë™ì‹œì— ìˆê±°ë‚˜ ë™ì‹œì— ì—†ë‹¤.
  placeOfBirth?: string;
  dateOfBirth?: Date;
}

// GOOD
interface Person {
  name: string;
  // í•˜ë‚˜ì˜ ê°ì²´ë¡œ ëª¨ì•„ì£¼ê¸°!
  birth?: {
    place: string;
    date: Date;
  };
}
```

### ê°™ì€ ìƒí™©ì´ì§€ë§Œ íƒ€ì…ì˜ êµ¬ì¡°ë¥¼ ì†ëŒˆ ìˆ˜ ì—†ë‹¤ë©´(ex. APIê²°ê³¼)

í•˜ë‚˜ì˜ ê°ì²´ë¡œ ëª¨ì•„ì£¼ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤ëŠ” ì–˜ê¸°...

ê·¸ëŸ¬ë©´ **ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨**ìœ¼ë¡œ ëª¨ë¸ë§ í•´ë³´ì!

```ts
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;
```

### ê²°ë¡ 

**ì†ì„±ê°„ì˜ ê´€ê³„ë¥¼ ëª…í™•íˆí•˜ëŠ” íƒ€ì…ì„ ì„¤ê³„í•˜ì**

ê·¸ ë°©ë²•ìœ¼ë¡œ ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨, í•˜ë‚˜ì˜ ê°ì²´ë¡œ ëª¨ìœ¼ê¸° ë“±ì´ ìˆë‹¤.

ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€ **ì†ì„±ê°„ì˜ ê´€ê³„ë¥¼ ëª…í™•íˆ í•˜ëŠ” ê²ƒ**

---

## **`ì•„ì´í…œ33` string íƒ€ì…ë³´ë‹¤ ë” êµ¬ì²´ì ì¸ íƒ€ì… ì‚¬ìš©í•˜ê¸°**

### ë¬¸ìì—´ì„ ë‚¨ë°œí•˜ì—¬ ì„ ì–¸ëœ íƒ€ì…(stringy typed)ì˜ ë¬¸ì œì 

```ts
interface Album {
  artist: string;
  title: string;
  releaseDate: string; // YYYY-MM-DD
  recordingType: string; // E.g., "live" or "studio"
}

const kindOfBlue: Album = {
  artist: 'Miles Davis',
  title: 'Kind of Blue',
  releaseDate: 'August 17th, 1959',
  recordingType: 'Studio',
};
// ì˜ëª»ëœ í˜•ì‹ì´ì§€ë§Œ íƒ€ì… ì²´ì»¤ëŠ” ì˜¤ë¥˜ë¥¼ ì¡ì§€ ëª»í•œë‹¤.(ë‹¹ì—°í•˜ë‹¤. íƒ€ì… ì„¤ê³„ì˜ ì˜¤ë¥˜ë‹ˆê¹Œ..)

function recordRelease(title: string, date: string) {
  /* ... */
}
recordRelease(kindOfBlue.releaseDate, kindOfBlue.title);

// ê°œë°œìì˜ ì‹¤ìˆ˜ë¡œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë‚˜ê² ì§€ë§Œ, íƒ€ì… ì²´ì»¤ëŠ” í†µê³¼í•œë‹¤.
```

### ì†ì„±ì˜ í˜•ì‹ì„ ì œí•œí•´ í•´ê²°í•´ë³´ì.

```ts
type RecordingType = 'studio' | 'live';

interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}
// ì†ì„±ì„ ëª…í™•íˆ í‘œí˜„í•œ íƒ€ì…ì´ë‹¤. (ì¢‹ì€ íƒ€ì… ì„¤ê³„ë‹¤)
```

### ì´ë ‡ê²Œ í–ˆì„ ë•Œ ì¥ì ì€??

- ëª…ì‹œì  íƒ€ì…ì„ í†µí•´ ë‹¤ë¥¸ ê³³ì—ì„œë„ íƒ€ì… ì •ë³´ê°€ ìœ ì§€ëœë‹¤.
- íƒ€ì…ì„ ì„¤ëª…í•˜ëŠ” ì£¼ì„ì„ ì¨ë‘˜ ê²½ìš° ì‚¬ìš©í•˜ëŠ” ê³³ì—ì„œ ì£¼ì„ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
- keyof ì—°ì‚°ìë¡œ ì„¸ë°€í•œ ê°ì²´ì˜ ì†ì„± ì²´í¬ê°€ ê°€ëŠ¥í•˜ë‹¤.

### ì–´ë–¤ ê°ì²´ì˜ ë°°ì—´ì—ì„œ í•œ í•„ë“œì˜ ê°’ë§Œ ì¶”ì¶œí•˜ëŠ” `pluck`í•¨ìˆ˜ íƒ€ì´í•‘í•˜ê¸°

```ts
// BAD
function pluck(record: any[], key: string): any[] {
  return record.map((r) => r[key]);
}

// any ë°˜í™˜ íƒ€ì…ì„ ì“¸ëª¨ê°€ ì—†ë‹¤.
// ì œë„ˆë¦­ì„ ë„ì…í•´ë³´ì

// BAD
function pluck<T>(record: T[], key: keyof T) {
  return record.map((r) => r[key]);
}

pluck(albums, 'releaseDate'); // Type is (string | Date)[]

// ì†ì„±ë“¤ì˜ íƒ€ì…ì´ string | Date ë¡œ ë­‰ëš±ê·¸ë ¤ì§„ ëª¨ìŠµ..
// ì ì ˆí•˜ì§€ ì•Šë‹¤. ìš°ë¦¬ëŠ” stringì„ ë‚¨ë°œí•˜ì§€ ì•Šê¸°ë¡œ í–ˆì—ˆë‹¤.
// íƒ€ì…ì˜ ë²”ìœ„ë¥¼ ë” ì¢í˜€ì•¼ í•œë‹¤. ë‘ ë²ˆì§¸ ì œë„ˆë¦­ì„ ë„ì…í•˜ì.

// GOOD
function pluck<T, K extends keyof T>(record: T[], key: K): T[K][] {
  return record.map((r) => r[key]);
}

pluck(albums, 'releaseDate'); // Type is Date[]
pluck(albums, 'artist'); // Type is string[]
pluck(albums, 'recordingType'); // Type is RecordingType[]

// ë°˜í™˜ íƒ€ì…ì˜ ë²”ìœ„ê°€ ëª…í™•í•´ì¡Œë‹¤. ì„¤ê³„ëœ íƒ€ì…ê³¼ ì˜ ë“¤ì–´ë§ëŠ” ëª¨ìŠµì´ë‹¤.
```

### ìš”ì•½

- `string`ì€ `any`ì™€ ë¹„ìŠ·í•˜ë‹¤. ë” êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ì.
  - ë¬¸ìì—´ ë¦¬í„°ëŸ´ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•´ë³´ì
- **ê°ì²´ì˜ ì†ì„± ì´ë¦„ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì„ ë•ŒëŠ” `string`ë³´ë‹¤ëŠ” `keyof T`ë¥¼ ì‚¬ìš©í•˜ì.**

---

## **`ì•„ì´í…œ34` ë¶€ì •í™•í•œ íƒ€ì…ë³´ë‹¤ëŠ” ë¯¸ì™„ì„± íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°**

### ë¶€ì •í™•í•œ íƒ€ì…ì˜ ì˜ˆì‹œ

```ts
type Expression1 = any;
type Expression2 = number | string | any[];
type Expression4 = number | string | CallExpression;

type CallExpression = MathCall | CaseCall | RGBCall;

interface MathCall {
  0: '+' | '-' | '/' | '*' | '>' | '<';
  1: Expression4;
  2: Expression4;
  length: 3;
}

interface CaseCall {
  0: 'case';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // etc.
}

interface RGBCall {
  0: 'rgb';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4;
}

const tests: Expression4[] = [
  10,
  'red',
  true,
  // ~~~ Type 'true' is not assignable to type 'Expression4'
  ['+', 10, 5],
  ['case', ['>', 20, 10], 'red', 'blue', 'green'],
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //  Type '["case", [">", ...], ...]' is not assignable to type 'string'

  ['**', 2, 31],
  // ~~~~~~~~~~~~ Type '["**", number, number]' is not assignable to type 'string
  ['rgb', 255, 128, 64],
  ['rgb', 255, 128, 64, 73],
  // ~~~~~~~~~~~~~~~~~~~~~~~~ Type '["rgb", number, number, number, number]'
  //                          is not assignable to type 'string'
];
const okExpressions: Expression4[] = [
  ['-', 12],
  // ~~~~~~~~~ Type '["-", number]' is not assignable to type 'string'
  ['+', 1, 2, 3],
  // ~~~~~~~~~~~~~~ Type '["+", number, ...]' is not assignable to type 'string'
  ['*', 2, 3, 4],
  // ~~~~~~~~~~~~~~ Type '["*", number, ...]' is not assignable to type 'string'
];
```

ì˜ëª» ì‚¬ìš©ëœ ì½”ë“œì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì§€ë§Œ, ì˜¤ë¥˜ë©”ì„¸ì§€ê°€ êµ‰ì¥íˆ ì´ìƒí•œ ëª¨ìŠµ..

ì–¸ì–´ì„œë¹„ìŠ¤ëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ê²½í—˜ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤.

ìœ„ì™€ ê°™ì€ ë°©ì‹ì€ ê°œë°œ ê²½í—˜ì„ í•´ì¹˜ê²Œ ëœë‹¤.(ì•Œì•„ë“¤ê¸° í˜ë“  ì˜¤ë¥˜ ë©”ì„¸ì§€, ìë™ ì™„ì„± ë°©í•´)

**ì‚¬ì‹¤ ë¶€ì •í™•í•œ íƒ€ì…ì´ì—ˆë‹¤?**

í‘œí˜„ì‹ì´ ì—¬ëŸ¬ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì„ ìˆ˜ ìˆë‹¤.

ì˜ˆë¥¼ ë“¤ë©´, `["+", 1, 2, 3, 4]` ë“±ê³¼ ê°™ì´..

í•˜ì§€ë§Œ íƒ€ì… ì„¤ê³„ê°€ ì˜ëª»ë˜ì–´ ì˜¤ë¥˜ë¥¼ í‘œì‹œí•˜ê²Œ ëœë‹¤.

### ê²°ë¡ 

ë§¤ìš° ì¶”ìƒì ì¸ íƒ€ì…ì€ ì •ì œê°€ í•„ìš”. í•˜ì§€ë§Œ êµ¬ì²´ì ì¼ìˆ˜ë¡ ì •í™•ë„ê°€ ì˜¬ë¼ê°€ëŠ”ê±´ ì•„ë‹ˆë‹¤.

ì •í™•í•œ íƒ€ì…ì„ ëª¨ë¸ë§í•  ìˆ˜ ì—†ë‹¤ë©´ ë¶€ì •í™•í•˜ê²Œ í•˜ê¸°ë³´ë‹¤ëŠ” ë¯¸ì™„ì„±ìœ¼ë¡œ ê°€ì.(ê·¸ë¦¬ê³  `any`ì™€ `unknown`ì„ êµ¬ë³„í•´ì„œ ì“°ì)

---

## **`ì•„ì´í…œ35` ë°ì´í„°ê°€ ì•„ë‹Œ APIì™€ ëª…ì„¸ë¥¼ ë³´ê³  íƒ€ì… ë§Œë“¤ê¸°**

### ì˜ˆì‹œ ë°ì´í„°ê°€ ì•„ë‹ˆë¼ ëª…ì„¸ë¥¼ ì°¸ê³ í•´ ì‹¤ìˆ˜ ì—†ëŠ” íƒ€ì…ì„ ìƒì„±í•˜ì

ì˜ˆì‹œ ë°ì´í„°ë¥¼ ì´ìš©í•´ ë§Œë“  íƒ€ì…ì€ ëˆˆì•ì— ìˆëŠ” ë°ì´í„°ë§Œ ê³ ë ¤í•˜ë¯€ë¡œ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

### ìë™ ìƒì„± íƒ€ì… ì‚¬ìš©í•˜ê¸°

- DefinitlyTyped: ì´ë¯¸ ì‘ì„±ëœ íƒ€ì… ì„ ì–¸
- GraphQL codegen: ì¿¼ë¦¬ë¥¼ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•´ì£¼ëŠ” ë„êµ¬
- DOM API: ë¸Œë¼ìš°ì €ì˜ DOM APIì— ëŒ€í•œ ë¯¸ë¦¬ ì„ ì–¸ëœ íƒ€ì…ë“¤

### ê²°ë¡ 

ëª…ì„¸ë¡œë¶€í„° íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ì´ë¯¸ ë§Œë“¤ì–´ì§„ ê²ƒë“¤ì´ ë§ìœ¼ë‹ˆ ì˜ ê°€ì ¸ë‹¤ ì“°ì.

---

## **`ì•„ì´í…œ36` í•´ë‹¹ ë¶„ì•¼ì˜ ìš©ì–´ë¡œ íƒ€ì… ì´ë¦„ ì§“ê¸°**

### íƒ€ì…ì˜ ì´ë¦„ ì§“ê¸°ëŠ” íƒ€ì… ì„¤ê³„ì˜ ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤

ì˜ëª»ëœ íƒ€ì… ì´ë¦„ì€ ì½”ë“œë¥¼ ì™œê³¡í•˜ê³  ì˜ëª»ëœ ê°œë…ì„ ì‹¬ëŠ”ë‹¤.

### ìì²´ì ìœ¼ë¡œ ìš©ì–´ë¥¼ ë§Œë“¤ì–´ ë‚´ë ¤ê³  í•˜ì§€ ë§ê³  í•´ë‹¹ ë¶„ì•¼ì˜ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìš©ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

í•˜ì§€ë§Œ ì „ë¬¸ ë¶„ì•¼ì˜ ìš©ì–´ëŠ” ì •í™•í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•œë‹¤. ì˜ëª» ì“°ê²Œ ë˜ë©´ ì§ì ‘ ë§Œë“¤ì–´ë‚¸ ìš©ì–´ë³´ë‹¤ ë” í˜¼ë€ì„ ì¤„ ìˆ˜ ìˆë‹¤.

```ts
// BAD
interface Animal {
  name: string;
  endangered: boolean;
  habitat: string;
}

const leopard: Animal = {
  name: 'Snow Leopard',
  endangered: false,
  habitat: 'tundra',
};
```

```ts
// GOOD
interface Animal {
  commonName: string;
  genus: string;
  species: string;
  status: ConservationStatus;
  climates: KoppenClimate[];
}
type ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';
type KoppenClimate = 'Af' | 'Am' | 'As' | 'Aw' | 'BSh' | 'BSk' | 'BWh'; // ê¸¸ì–´ì„œ ìƒëµ

const snowLeopard: Animal = {
  commonName: 'Snow Leopard',
  genus: 'Panthera',
  species: 'Uncia',
  status: 'VU', // ì·¨ì•½ì¢…
  climates: ['ET', 'EF', 'Dfd'], // ê³ ì‚°ëŒ€ or ì•„ê³ ì‚°ëŒ€
};
```

### ì´ë¦„ì„ ì§€ì„ ë•Œ ëª…ì‹¬í•´ì•¼ í•  3ê°€ì§€ ê·œì¹™

- ë™ì¼í•œ ì˜ë¯¸ëŠ” ê°™ì€ ì´ë¦„ì„
  - ì •ë§ë¡œ ì˜ë¯¸ì ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ì•¼ í•˜ëŠ” ê²½ìš°ì—ë§Œ ë‹¤ë¥¸ ìš©ì–´ ì‚¬ìš©í•˜ê¸°
- data, info, thing, item, object, entity ê°™ì€ ì˜ë¯¸ ì—†ëŠ” ì´ë¦„ì€ í”¼í•˜ê¸°
- ì´ë¦„ì„ ì§€ì„ ë•ŒëŠ” í¬í•¨ëœ ë‚´ìš©ì´ë‚˜ ê³„ì‚° ë°©ì‹ì´ ì•„ë‹ˆë¼ ë°ì´í„° ìì²´ê°€ ë¬´ì—‡ì¸ì§€ ê³ ë ¤í•˜ê¸°
  - êµ¬í˜„ì˜ ì¸¡ë©´(í¬í•œëœ ë‚´ìš©)ì—ì„œ ì§€ì€ ì´ë¦„: `INodeList`
  - ê°œë…ì  ì¸¡ë©´ì—ì„œ ì§€ì€ ì´ë¦„: `Directory` (ì¶”ìƒí™” ìˆ˜ì¤€ì„ ë†’ì„ ğŸ‘)

---

## **`ì•„ì´í…œ37` ê³µì‹ ëª…ì¹­ì—ëŠ” ìƒí‘œë¥¼ ë¶™ì´ê¸°**

### íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ êµ¬ì¡°ì  íƒ€ì´í•‘ì˜ í•œê³„

```ts
interface Vector2D {
  x: number;
  y: number;
}
function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm({ x: 3, y: 4 }); // OK, result is 5
const vec3D = { x: 3, y: 4, z: 1 };
calculateNorm(vec3D); // OK! result is also 5
// ì˜ë„ì™€ ë§ì§€ ì•ŠëŠ” ëª¨ìŠµ
```

ìœ„ì™€ ê°™ì€ ê²½ìš° ìƒí‘œë¥¼ ì´ìš©í•´ì„œ `calculateNorm`ì´ `Vector2D`ë§Œ ë°›ëŠ” ê²ƒì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

```ts
interface Vector2D {
  _brand: '2d'; // ìƒí‘œ ë¶™ì´ê¸°
  x: number;
  y: number;
}
function vec2D(x: number, y: number): Vector2D {
  return { x, y, _brand: '2d' };
}
function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y); // Same as before
}

calculateNorm(vec2D(3, 4)); // OK, returns 5
const vec3D = { x: 3, y: 4, z: 1 };
calculateNorm(vec3D);
// ~~~~~ Property '_brand' is missing in type...
```

ìƒí‘œ ê¸°ë²•ì€ íƒ€ì… ì‹œìŠ¤í…œì—ì„œ ë™ì‘í•˜ì§€ë§Œ ëŸ°íƒ€ì„ì—ì„œ ê²€ì‚¬í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•œ íš¨ê³¼ë¥¼ ì–»ëŠ”ë‹¤.

ë”°ë¼ì„œ ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œë¥¼ ì—†ì•¨ ìˆ˜ ìˆë‹¤.

### string íƒ€ì…ì—ì„œì˜ ìƒí‘œ ê¸°ë²•ì„ ì•Œì•„ë³´ì

```ts
type AbsolutePath = string & { _brand: 'abs' };
function listAbsolutePath(path: AbsolutePath) {
  // ...
}
function isAbsolutePath(path: string): path is AbsolutePath {
  return path.startsWith('/');
}

// íƒ€ì…ê°€ë“œê°€ ì˜ ë™ì‘í•˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.
function f(path: string) {
  if (isAbsolutePath(path)) {
    listAbsolutePath(path);
  }
  listAbsolutePath(path);
  // ~~~~ Argument of type 'string' is not assignable
  //      to parameter of type 'AbsolutePath'
}
```

ì‹¤ì œ `string`ì´ë©´ì„œ `_brand`ì†ì„±ì„ ê°€ì§€ëŠ” ê°’ì€ ì—†ë‹¤. ì˜¨ì „íˆ íƒ€ì… ì‹œìŠ¤í…œì—ì„œë§Œ ê°€ëŠ¥

### íƒ€ì… ì²´ì»¤ë¥¼ ìœ ìš©í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ íŒ¨í„´ ì•Œì•„ë³´ê¸°

```ts
type SortedList<T> = T[] & { _brand: 'sorted' };

// ëŸ°íƒ€ì„ì— ë™ì‘í•˜ëŠ” íƒ€ì… ê°€ë“œë¼ íš¨ìœ¨ì ì´ì§„ ì•ŠìŒ. í•˜ì§€ë§Œ ì•ˆì „ì„± ë³´ì¥
function isSorted<T>(xs: T[]): xs is SortedList<T> {
  for (let i = 1; i < xs.length; i++) {
    if (xs[i] > xs[i - 1]) {
      return false;
    }
  }
  return true;
}

function binarySearch<T>(xs: SortedList<T>, x: T): boolean {
  // ...
}
```

### number íƒ€ì…ì—ë„ ìƒí‘œë¥¼ ë¶™ì¼ ìˆ˜ ìˆì§€ë§Œ ì—°ì‚° í›„ì—ëŠ” ì—†ì–´ì ¸ ì‚¬ìš©ì— ë¬´ë¦¬ê°€ ìˆë‹¤ê³  í•œë‹¤.

> stringì— ë¶™ì¸ ìƒí‘œëŠ” í•­ìƒ ìœ ì§€ë˜ëŠ” ê±¸ê¹Œ?
