# ch02: 타입스크립트의 타입 시스템 (1)

---

## 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

---

### 편집기(VS Code) 사용하기

- TS의 타입 추론 결과를 시각적으로 확인할 수 있다.
    - 타입이 의도한 것과 다르다면 타입 선언을 직접 명시하자
    - 조건문 분기에서 값의 타입이 어떻게 변하는지 살펴보자
    - 연산자 체인 중간의 추론된 제네릭 타입을 알기 위해서는 메서드 이름을 조사하자

### 📌 null 체크 관련

- **자바스크립트에서 `typeof null`은 `object`이다.**
- 타입 가드로 object를 검사할 때, null에 대한 예외 처리를 해야 한다.
- document의 html 요소는 null일 가능성이 있다.
    - null 체크를 추가하고 예외를 던져야 한다.

### 언어 서비스

- 언어 서비스란 코드 편집기에서 제공하는 자동 완성, 문법 강조, 오류 감지, 코드 포맷팅, 리팩토링 등의 기능을 의미한다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해, `Go to Definition` 옵션으로 타입 선언 파일을 확인할 수 있다. (***lib.dom.d.ts*** 파일)

**한 줄 요약**

⇒ 편집기 프로그램 사용하세요.

## 아이템 7 타입이 값들의 집합이라고 생각하기

---

타입스크립트에서의 타입을 **‘할당 가능한 값들의 집합’**이라고 생각하자. 집합은 타입의 ‘범위’라고 부를 수 있다. 가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 이는 never 타입이다. 여기에는 아무런 값도 할당할 수 없다.

### never

```tsx
const x: never = 12;
// ~ '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

### literal, unit

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

- 공집합 다음으로 가장 작은 집합은 한 가지 값만 포함하는 타입
- 유닛(unit) 타입이라고도 불리는 리터럴(literal) 타입이다.

### union

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

- 두 개 혹은 세 개로 묶으려면 유니온(union) 타입을 사용한다.
- 유티온 타입은 값 집합들의 합집합을 일컫는다.

<aside>
😒 TS 에러에서 ‘할당 가능한’ 이라는 문구의 집합 관점에서 뜻은 ‘~의 원소(값과 타입의 관계)’ 또는 ‘~의 부분 집합(두 타입의 관계)’을 의미한다.

</aside>

집합의 관점에서, 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있다.

타입스크립트의 타입 시스템은 값들의 집합이라고 생각하면 이해하기 쉬워진다고 말한다. 

### 겹치지 않는 타입으로 이루어진 연산

```tsx
interface Person {
	name: string;
}
interface Lifespan {
	birth: Date;
	death?: Date;
}
type PersonSpan = Person & Lifespan;

const ps: PersonSpan = {
	name: 'Alan Turing',
	birth: new Date('1912/06/23'),
	death: new Date('1954/06/07'),
}; // - OK!
```

Person과 Lifespan 인터페이스는 공통으로 가지는 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬우나, **타입 연산자는 인터페이스의 속성이 아닌 값의 집합(타입의 범위)에 적용**된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다.

📌 **때문에 Person과 Lifespan을 둘 다 가지는 값은 인터섹션 타입에 속하게 된다. 당연히 앞의 세 가지보다 더 많은 속성을 가지는 값도 PersonSpan 타입에 속한다.** 

인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙이다. 규칙이 속성에 대한 인터섹션에 관해서는 맞지만, 두 인터페이스의 유니온에서는 그렇지 않다.

```tsx
type K = keyof (Person | Lifespan); // never
```

```tsx
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

- 이걸 이해하면 타입스크립트의 타입 시스템을 이해하는 데 큰 도움이 된다고 한다.

<aside>
😒 잘 이해가 안된다. 더 파봐야겠다.

</aside>

### 더 이해하기

---

### 오브젝트에서 부분 집합 관계 생각해보기

```tsx
interface Creature {
	name: string;
	birth: number;
	gender: "M" | "F";
}
interface Person {
	name: string;
	birth: number;
	gender: "M" | "F";
	nationality: string;
}
```

- 여기서 Creature와 Person 중 어떤 것이 부분집합인가?
    - 정답은 **Person**이다.
    - 오브젝트에서 프로퍼티는 ‘제약 조건’이라고 생각해야 한다.
    - 무수히 많은 값의 공간에서 Person 타입의 오브젝트가 될 수 있는 오브젝트는 동시에 Creature라는 오브젝트가 될 수 있다. 그러나 반면 Creature 타입의 오브젝트들은 항상 Person의 오브젝트가 된다고 말할 수 없다.
        - nationality가 있어야 Person이 되기 때문이다.
    - 따라서 상위 집합은 Creature이고, Person이 부분집합이다.
    - **이렇게 생각한다면 Creature와 Person의 교집합은?**
        
        **⇒ Person이다.**
        
        ![Untitled](ch02%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B4%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20(1)%20db65014414084783b5c4f3d87c36feb7/Untitled.png)
        
- 상속으로 설명하면 더 간단해진다.
    
    ```tsx
    interface Creature {
    	name: string;
    	birth: number;
    	gender: "M" | "F";
    }
    interface Person extends Creature {
    	nationality: string;
    }
    ```
    
    - **부분 집합이라는 것은 특정 타입을 상속받는 것**과 동일한 의미를 가진다.
    

### 이제 다시 예제 이해해보기

```tsx
interface Person {
	name: string;
}
interface Lifespan {
	birth: Date;
	death?: Date;
}
type PersonSpan = Person & Lifespan;

const ps: PersonSpan = {
	name: 'Alan Turing',
	birth: new Date('1912/06/23'),
	death: new Date('1954/06/07'),
}; // - OK!
```

- **Person과 Lifespan의 교집합이 왜 ps가 될 수 있는가?**
    - 값이 무한대에 가까운 집합 사이에서,
    - → name을 가지고, 더 많은 제약 조건(속성)을 가진 집합이 Person의 부분 집합이 된다.
    - → birth와 death를 가지고, 더 많은 제약 조건(속성)을 가진 집합이 Lifespan의 부분집합이 된다.
        - 이것을 코드로 표현하면,
        
        ```tsx
        const sub1 = {
        	name: string,
        	gender: "M"
        }
        ```
        
        sub1은 Person의 교집합이다.
        
        ```tsx
        const sub2 = {
        	birth: new Date('1912/12/01'),
        	death: new Date('1979/04/05'),
        	activeCentury: 20,
        }
        ```
        
        sub2는 Lifespan의 교집합이다.
        
    - 그렇다면 아래 코드는
        
        ```tsx
        const sub3 = {
        	name: "anonymous",
        	gender: "M",
        	birth: new Date('1912/12/01'),
        	death: new Date('1979/04/05'),
        	activeCentury: 20
        }
        ```
        
        sub3은 Person의 교집합이기도 하고, Lifespan의 교집합이기도 하다.
        Person & Lifespan의 결과는 무수히 많은 객체들 사이에서 name, birth, death를 가지는 값이 속하게 된다.
        

### 한 줄 요약

***속성을 더 적게 가지고 있는 오브젝트가 더 큰 오브젝트다?*** 

### 그렇다면 유니온은?

- 속성이 많은 것이 더 작은 집합이라면, 합집합은 어떻게 생각해야 하나?
    - 합집합은 Person 타입이거나 Lifespan 타입이 되어야 한다.
    - `Person | Lifespan` 타입인 경우?
        1. 속성에 name만 있는 경우
        2. 속성에 birth만 있는 경우
        3. 속성에 name과 birth만 있는 경우
        4. 속성에 name과 death만 있는 경우
        5. 속성에 name과 birth, 그리고 death만 있는 경우
    - `keyof (Person | Lifespan)`이 `never` 타입인 이유는?
        - Person 과 Lifespan의 유니온 타입이 어떤 속성을 가질 지 알 수 없기 때문?
        - 위의 다섯 가지 중 어떤 경우인지 알 수 없다?

## 아이템 8 타입 공간과 값 공간의 심벌 구분하기

---

타입스크립트 코드에서 해당 심볼이 타입인지 값인지 구분할 수 있어야 한다. 모든 값에는 타입이 존재하지만 타입은 값을 가지지 않는다. 타입 맥락을 잘 이해할 수 있다면 구분하기 쉽다. 아이템 8에서 기억해야 할 것들을 문장으로 정리하여 나열하면 아래와 같다.

- instanceof는 자바스크립트 런타임 연산자이기에 값에 대한 연산을 한다.
- type (타입 별칭) 또는 interface 다음에 나오는 심볼은 타입이며, const나 let 뒤에 오는 심볼은 값이다.
- 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다. (순서 짬뽕일 수 있다.)
- 타입 선언 (:) 또는 단언문 (as) 다음에 나오는 심볼은 타입이며, = 다음에 나오는 모든 것은 값이다.
- class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능하다.
    - 클래스가 타입으로 쓰일 때는 속성과 메서드가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용된다.
- typeof 연산자는 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.
    - 값에서 쓰일 때는 피연산자의 타입을 문자열로 반환한다.
    - 타입일 경우 값을 읽어 타입스크립트 타입을 반환한다.
- 속성 접근자 []는 타입으로 쓰일 때에도 동일하게 동작하지만, obj[’field’]와 obj.field는 값은 같더라도 타입은 다를 수 있다.
    - 타입의 속성을 얻기 위해서는 반드시 obj[’field’]를 사용해야 한다.
        
        🙄 ‘값은 .을 쓰고 타입은 [’field’]로 나누어 쓰면 편하지 않을까…?’
        
- 값으로 쓰이는 this는 JS의 this 키워드이고, 타입으로 쓰이는 this는 다형성 this라고 불리는 this의 타입스크립트 타입이다.
- 값에서 &와 |는 AND와 OR 비트 연산이고, 타입에서 &와 |는 인터섹션과 유니온이다.
- const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다. (?)
- extends는 (서브클래스 또는 서브타입)이거나 (제네릭 타입의 한정자)이다.
- in은 루프문 또는 매핑된 타입에 등장한다. (?)

## 아이템 9 타입 단언보다는 타입 선언을 사용하기

---

타입스크립트에서 타입을 부여하는 방법 두 가지는 타입 단언과 타입 선언이 있다.

```tsx
interface Person {
	name: string
}

const dongho: Person = {
	name: 'Dongho'
}

const khakhid = {
	name: 'Khakid'
} as Person;
```

- 첫 번째는 타입 선언이고, 두 번째는 타입 단언이다.
- 타입 선언의 경우 변수의 값이 선언된 타입을 명시한다.
- 타입 단언의 경우 타입스크립트가 추론한 타입이 있더라도 Person으로 간주한다.

타입 선언은 할당 값이 인터페이스를 만족하는지 검사하지만, 단언의 경우 강제로 지정하므로 타입 체커의 결과를 무시하라고 하는 것과 같다.

<aside>
😒 **타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크가 되는 타입 선언을 사용하자.**

</aside>

### 화살표 함수의 타입 선언

화살표 함수 방식으로 작성된 함수의 타입 선언은 추론 타입이 모호할 때가 있다.

```tsx
const people = ['alice', 'bob', 'jan'].map(
	name => ({ name } as Person
);
// Person[] 타입
```

타입 단언이 아닌 변수를 선언하여 타입 선언하는 것이 가장 직관적이다.

```tsx
const people = ['alice', 'bob', 'jan'].map(name =>
	const person: Person = { name };
	return person;
);
// Person[] 타입
```

이 방법은 기존 코드에 비해 조금 번잡해 보이니, 조금 더 간결하게 화살표 함수의 반환 타입을 선언해보도록 하자.

```tsx
const people = ['alice', 'bob', 'jan'].map(
	(name): Person => ({ name })
);
// Person[] 타입
```

위 코드는 바로 이전 코드와 동일한 체크를 수행한다. (name) 사이에 있는 소괄호가 매우 중요한 역할을 하는데, (name): Person은 name의 타입이 없고, 반환 타입이 Person이라고 명시하고 있다.

그러나 (name: Person)은 name의 타입이 Person임을 명시하고 반환 타입이 없기에 에러가 발생한다.

```tsx
const people: Person[] = ['alice', 'bob', 'jan'].map(
	(name): Person => ({ name })
);
```

`함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.` 그래야만 정확한 곳에 오류가 표시된다.

### 타입 단언이 꼭 필요한 경우

타입 단언은 타입 체커가 추론한 타입보다 개발자가 판단한 타입이 더 정확할 때 의미가 있다. 예를 들어, **DOM 요소에 대해서는 TS보다 개발자가 더 정확히 알고 있다.**

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 체커가 알지 못하는 정보를 가지고 있는 개발자가 타입 단언문을 사용하는 것이 타당하다. non-null(!) 문법을 사용하여 null이 아님을 단언하는 경우도 주로 DOM 요소를 다룰 때이다.

```tsx
const elNull = document.getElementById('foo'); // 타입은 HTMLElement | null
const el = document.getElementById('foo')**!**; // 타입은 HTMLElement
```

임의의 타입 간에 타입 단언문으로 변환할 수는 없다. A가 B의 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

- HTMLElement는 HTMLElement | null의 서브타입이기에 동작한다.
- HTMLButtonElement는 EventTarget의 서브타입이기 때문에 동작한다.
- Person은 {}의 서브타입이므로 동작한다.
- 📌 그러나 Person과 HTMLElement는 서로의 서브타입이 아니기 때문에 변환이 불가능하다.

```tsx
interface Person {
	name: string;
}
const body = document.body;
const el = body as Person;
// ~~~~ Error!
```

- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서만 타입 단언문과 non-null 단언을 하면 된다.

<aside>
😒 ‘non-null 연산자 (!)는 일반적인 타입 단언문으로 해석하면 된다.’

</aside>

## 아이템 10 객체 래퍼 타입 피하기

---

- 자바스크립트에는 객체 타입외에 원시형 타입이 있다.
- 원시형 타입은 불변이며 메서드를 가지지 않는다는 점이 객체와 다르다.
- 그런데 string의 경우 메서드를 가지고 있는 것처럼 보인다.
- 사실 이것은 string의 메서드가 아니라 String 객체 타입이 정의되어 서로 변환하기 때문이다.
- **원시형 타입에 charAt()과 같은 메서드를 사용할 때, string 타입을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버리는 과정을 거친다.**

문제는, String 객체 래퍼와 string 원시형 타입이 항상 동일하게 동작하지 않는다는 점에 있다.

- String 객체는 오직 자기 자신만 동일하다.

```tsx
"hello" === new String("hello") // false
new String("hello") === new String("hello") // false
```

- 어떤 속성에 원시형을 할당하면 그 속성이 사라진다.

```tsx
x = "hello"
x.language = "English"
x.language // undefined
```

이것은 x가 String 객체로 변환된 후 lnaguage 속성이 추가되고 lnaguage 속성이 추가된 객체가 버려지기 때문이다.

number는 Number 객체, boolean은 Boolean 객체, symbol에는 Symbol, bigint에는 BigInt 객체가 존재한다. **타입스크립트는 원시형과 객체 래퍼 타입을 별도로 모델링한다.**

string을 사용할 때는 특히 유의해야 한다. string을 String이라고 잘못 타이핑 하기 쉽고, 실수하더라도 처음에 잘 동작하는 것처럼 보이기 때문이다.

- string은 String에 할당할 수 있지만, 반대로 String은 string에 할당할 수 없다.
- 타입스크립트가 제공하는 타입 선언은 전부 원시형 타입으로 되어 있다.
- 타입스크립트에서 래퍼 객체를 사용하려면 타입의 첫 글자를 대문자로 표기한다.
    - `const s: String = "primitive";`

📌 new 없이 BigInt와 Symbol을 호출하는 경우는 원시형을 생성하기에 사용해도 무관하다.

## 아이템 11 잉여 속성 체크의 한계 인지하기

---

<aside>
😒 **잉여 속성 체크**
객체 리터럴이나 인터페이스에서 정의되지 않은 속성을 갖는 경우 컴파일러가 경고 또는 에러를 발생시키는 개념. 잉여 속성 체크를 비활성화하려면 noImplicitAny 설정을 해주면 된다. 하지만 보다 안전한 코드를 작성하기 위해서는 잉여 속성 체크를 활성화하는 것이 권장된다.

</aside>

```tsx
interface Person {
  name: string;
  age: number;
}
```

```tsx
const person: Person = {
  name: "Alice",
  age: 30,
  city: "New York", // 잉여 속성
};
```

- city 속성은 잉여 속성이 된다.
- 타입스크립트는 이를 잡아내고 경고 또는 에러를 발생시킨다.

하지만 아래 코드는 또 타입 체커를 통과한다.

```tsx
const obj = {
	name: "Dongho",
	age: 27,
	city: "Busan",
}
const dongho: Person = obj; // OK!
```

타입스크립트 타입은 범위가 아주 넓어질 가능성이 있기 때문에, 잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않는다.

### 임시 변수를 사용하면 잉여 속성 체크가 되지 않음

```tsx
interface Options {
	title: string;
	darkMode?: boolean;
}

const o1: Options = document; // 정상. string이 있음 -> 구조적 타입
const o2: Options = new HTMLAnchorElement; // 정상. 위와 같음

const o3: Options = {darkmode: true, title: 'Ski Free'}; // 객체 리터럴
// ~~~~~ 'Options' 형식에 'darkmode'이(가) 없습니다. - 오타

const intermediate = { darkmode: true, title: 'Ski Free' };
const o4: Options = intermediate;
**// 정상 - 객체 리터럴이 아니기에 잉여 속성 체크가 되지 않음**

const o5 = { darkmode: true, title: 'Ski Free' } as Options; // 정상
// 타입 단언문을 사용하면 잉여 속성 체크가 되지 않음. 선언문을 쓰세요~ ^.^;
```

의도적으로 잉여 속성 체크를 하지 않게 하려면 인덱스 시그니처를 도입하는 방법도 있다.
(이 방법이 적절한지 아닌지는 아이템 15에서 다룬다.)

```tsx
interface Options {
	darkMode?: boolean;
	[otherOptions: string]: unknown;
}
const o: Options = {darkmode: true}; // 정상
```

**두 줄 요약**

- 잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름 오타와 같은 실수를 잡는 데 효과적이다.
- **오직 객체 리터럴에만 적용**되어 범위도 매우 제한적이라는 한계점이 있으니 이를 인지하여야 한다. 임시 변수를 도입할 경우 잉여 속성 체크를 건너뛸 수 있다는 점을 기억하자.