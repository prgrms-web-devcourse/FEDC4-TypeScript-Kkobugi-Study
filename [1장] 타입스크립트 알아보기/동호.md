# 챕터 1. 타입스크립트 알아보기

## 아이템1. 타입스크립트와 자바스크립트의 관계 이해하기

---

- TS는 JS의 상위 집합(superset)이다.
- TS 타입 시스템은 JS의 런타임 동작을 ‘모델링’한다.
  - 런타임 에러가 발생하지 않는 코드에도 타입 체커는 문제점을 표시할 수 있다.
  - 타입 시스템은 정적 타입에 대한 정확도를 보장하지 않는다.
  - 하지만 이런 모델링 구조에 대한 내용은 개인의 취향이며 우열을 가릴 수 없다.

> **_TS는 코드의 ‘의도’를 명시할 수 있다._**

<aside>
😒 <strong>‘자바스크립트의 미친 유연함이 가져다주는 부작용을 줄이고 개발자의 실수를 줄이기 위해 결국 자바, C#과 같은 안정성을 추가한 놈이군…’</strong>

</aside>

## 아이템2. 타입스크립트 설정 이해하기

---

- **strict 모드를 키십쇼.**
  - `noImplicitAny`: 암시적 any 타입을 허용하지 않음
  - `strictNullChecks`: null, undefined를 모든 타입에서 허용하지 않음
- tsc 커맨드보다 tsconfig.json 쓰는게 더 편하다.

## 아이템3. 코드 생성과 타입이 관계없음을 이해하기

---

### **TS 컴파일러의 역할 두 가지**

1. **최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 트랜스파일**
2. **코드의 타입 오류를 체크**

이 역할 두 가지는 서로 독립적이기에 TS 코드의 타입은 트랜스파일에 영향을 주지 않는다.

### **TS 코드에 타입 에러가 있더라도 정상적으로 컴파일이 될 수 있다.**

- 기술적으로 컴파일 에러가 아닌 타입 체크 에러라고 칭해야 한다.
- `noEmitOnError`: 타입 체크 에러가 있다면 컴파일하지 않도록 설정하는 옵션

### **타입에 대한 정보는 런타임 시기에는 모두 사라진다.**

타입 정보를 유지하는 방법으로는 속성이 존재하는지 체크하는 방법 또는 태그 기법을 사용할 수 있다.

- **속성이 존재하는지 체크하는 방법**

  ```scss
  interface  Square {
    width: number;
  }

  interface Rectangle extends Square {
    height: number;
  }

  type Shape = Square | Rectangle;

  function calculateArea(shape: Shape) {
    if ('height' in shape) {
      shape; // shape는 Rectangle
      return shape.width * shape.height;
    } else {
      shape; // shape는 Square
      return shape.width * shape.width;
    }
  }
  ```

  `if ('height' in shape)`는 런타임에 이루어지는 속성 값 체크다. TS 타입 체크 시스템은 이 조건문을 통해서 `shape` 객체의 타입을 추론한다. `shape` 객체에 `height` 속성이 있다면 `Rectangle` 타입일 것이고, 없다면 `Square` 타입일 것이라는 걸 추론한다는 뜻이다.

  중요한 점은 여기서 `in` 연산자가 런타임에 프로퍼티 존재 여부를 체크하기에 이러한 타입 체크는 동적으로 이루어진다는 점이다. 컴파일 시의 타입 안정성을 보장해준다.

    <aside>
    😒 <strong>‘강의에서 배운 타입 가드 개념을 활용한 것이구만…’</strong>
    
    </aside>


- **‘태그’ 기법을 사용하는 방법**
  > _‘태그’ 기법이란 객체에 문자열이나 숫자 형태 등의 특정 필드(주로 ‘kind’)를 추가하여 런타임에도 타입 정보를 유지하는 방법이다. 과도하게 사용할 경우 코드 복잡성이 증가할 수 있으므로 꼭 필요한 객체에 선택적으로 적용해야 한다._

<aside>

**타입으로 참조하는 경우**

타입을 정의하고 이를 다른 타입이나 변수, 함수, 인터페이스 등에서 사용할 때를 말한다. 즉, 타입을 변수에 할당하거나, 함수의 매개변수나 반환 타입으로 사용하거나, 인터페이스의 속성 타입으로 사용하는 등의 상황을 의미.

```tsx
type Name = string;
type Age = number;
interface Person {
  name: Name;
  age: Age;
}
```

**값으로 참조하는 경우**

타입을 직접적으로 변수에 할당하거나, 함수에 인자로 전달하는 등의 상황을 의미한다. 즉, 타입 자체를 값을 가진 변수로 다루는 경우를 말한다.

```tsx
const myType: { name: string } = {
  name: 'TypeScript',
};
```

요약하면 코드에서 타입을 정의하고 재사용할 때는 타입으로 참조하는 것이고, 코드에서 타입을 값처럼 사용하는 부분이 값으로 참조하는 것이다.

</aside>

### 타입 연산은 런타임에 영향을 주지 않는다.

TS 타입 시스템은 코드를 컴파일하는 단계에서만 작동하고, **런타임에는 타입 정보가 삭제되어 영향을 주지 않는다**는 뜻이다.

타입 연산이란 타입 체크, 타입 추론, 제네릭 타입 매개변수, 인터페이스 등의 정적 타입 단계에서 데이터를 다루는 작업을 의미한다. TS 컴파일러에 의해서 해석되고 처리된 후 런타임에서는 걍 JS 쓰니까 영향 주지 않는다는 뜻이다.

### 런타임 타입은 선언된 타입과 다를 수 있다.

- TS 코드에서 선언된 타입과 런타임의 타입은 서로 같지 않을 수 있다는 것
- 최대한 이런 상황을 피해야 하며, 선언된 타입이 언제든 달라질 수 있다는 것을 명심하기

### TS 타입으로는 함수를 오버로드 할 수 없다.

> ‘_함수 오버로드’는 같은 이름에 매개변수만 다른 여러 함수를 선언하는 것을 말한다._

- TS에서는 타입과 런타임 동작이 무관 ⇒ 함수 오버로딩이 불가능
- 함수 오버로딩 기능을 지원은 하지만 타입 수준에서만 동작하고, 실제 구현체 (JS 코드의 함수)는 오직 하나 뿐이다.

### TS 타입은 런타임 성능에 영향을 주지 않는다.

타입에 대한 정보는 런타임 시기에 모두 사라지니 성능에는 영향이 없다.

<aside>
😒 <strong>‘이 부분 읽고 말도 안된다고 생각해서 알아봤더니, 아주 미미한 정도이기에 성능 저하를 느끼지 못한다고 한다. 그런데 궁금증을 아래 문단에서 알려준다.’</strong>

</aside>

- 런타임 오버헤드가 없는 대신 빌드타임 오버헤드가 있다.
  > _‘오버헤드(overhead)’란 특정 작업이 추가적인 비용 또는 부담(주로 추가적인 리소스 혹은 시간, 복잡성 등)을 가지고 발생하는 것을 의미한다._
  프로그램이 실행되는 시점에 발생하는 추가적 비용을 런타임 오버헤드라고 하며 메모리, CPU, 네트워크 등의 자원을 더 많이 사용하거나 추가적인 계산을 필요로 하는 상황에서 발생한다.
  빌드타임 오버헤드는 프로그램을 빌드하는 과정에서의 추가적인 비용이 발생하는 것을 말한다. 즉 TS 컴파일러가 TS 코드를 JS로 변환하는 시간과 자원을 의미한다. TS 버전이 올라갈 수록 이 빌드타임 오버헤드는 대부분의 경우 무시할 수준으로 작아졌다고 한다.
  ⇒ **결론** 성능에 거의 영향 없다고 보면 된다. 걍 써라.
- 그런데 TS를 트랜스파일하는 과정에서 어떤 JS 버전을 호환하는지에 따라 성능을 높일지 호환성을 높일지가 결정된다. 이건 전략적 선택이 필요할 것.

## 아이템4. 구조적 타이핑(structural typing)에 익숙해지기

---

JS와 TS의 중요한 차이점 중 하나로 JS는 본질적으로 덕 타이핑(duck typing) 기반이고, TS는 구조적 타이핑(structural typing) 기반이라는 것이다.

<aside>
📎 **덕 타이핑 (duck typing)**
”오리처럼 걷고, 오리처럼 소리를 내면, 그것은 오리다.”라는 말에서 유래한 개념으로 객체의 타입이나 클래스가 아니라 객체의 속성과 메서드의 집합에 따라서 객체의 타입을 결정하는 방식이다. 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주한다.

**구조적 타이핑 (structural typing)**
덕 타이핑과 유사한 개념이지만, 클래스나 인터페이스의 이름이 중요하지 않고 **구조(속성과 메서드의 집합)**가 중요한 타입 시스템을 말한다. 서로 다른 이름의 두 타입이 구조적으로 호환이 가능하면, 이 두 타입은 같은 타입으로 간주한다.

</aside>

<aside>
😒 <strong>예시 코드들이 무슨 2D 벡터, 3D 벡터와 벡터 정규화 등이어서 이해하기가 어려웠(~~싫었~~)다. 아래와 같은 다른 예제를 가져와서 이해하려고 했다.'</strong>

</aside>

TS는 아래 두 인터페이스가 구조적으로 호환된다.

```tsx
interface User {
  name: string;
  age: number;
}

interface Employee {
  name: string;
  occupation: string;
}
```

이 두 인터페이스가 구조적으로 호환되므로 다음과 같이 `printInfo` 함수의 매개변수에 `Employee`도 사용할 수 있다는 것이다.

```tsx
function printInfo(info: User) {
  console.log(`Name: ${info.name}`);
}

const user: User = { name: '동호', age: 27 };
const employee: Employee = { name: '바보', occupation: 'Developer' };

printInfo(user); // 출력: Name: 동호
printInfo(employee); // 출력: Name: 바보
```

- 구조적 타이핑으로 인해 발생하는 문제점
  TS에서는 함수 매개변수에서 기대하는 타입과 조금 다른 타입을 가지더라도 타입 호환성을 유지하기 때문에 잘못된 인자를 전달하는 경우에도 타입 체커에서 에러를 감지하지 못하는 경우가 있다. ⇒ 이런 경우를 에러로 처리하기 위한 설정이 존재함
- 구조적 타이핑으로 인한 장점
  - 유닛 테스팅에 더 효율적이다.
  - 라이브러리 간의 의존성을 완벽히 분리할 수 있다. (아이템 51)

<aside>
😒 <strong>‘이 부분 잘 이해가 안되는 것 같다. 물어봐야지…'</strong>

</aside>

> **_‘타입스크립트 타입 시스템은 봉인된(sealed) 또는 정확한(precies) 타입이 아니고, 열려(open) 있다.’ 고 표현한다. 이러한 특성은 의도하지 않은 결과를 낳을 수 있다._**

## 아이템5. `any` 타입 지양하기

---

**한 줄 요약**

- `any` 쓰지 마. (쓰라할 때 빼고)</strong>

**일부의 경우를 제외하고 any를 사용하는 경우 TS의 효용을 거의 누릴 수 없다.**

- any 타입에는 타입 안정성이 없다.
- any는 함수 시그니처를 무시한다.
- any 타입에는 언어 서비스가 적용되지 않는다.
  - TS의 모토는 **“확장 가능한 자바스크립트”**이다.
- any 타입은 코드 리팩터링 때 버그를 감춘다.
- any는 타입 설계를 감춘다.
- any는 타입 시스템의 신뢰도를 떨어뜨린다.

![Untitled](1%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20306ed03e38624d2192a70c29764c14af/Untitled%201.png)

## 1장을 읽으면서

---

서론에 따르면 이 책(이펙티브 타입스크립트)은 자바스크립트 혹은 타입스크립트로 작업해본 경험이 있는 초급자나 중급자를 대상으로 하고 있다고 분명히 하고 있습니다. 책의 제목과 같이 타입스크립트를 어떻게 사용해야 효율적으로 사용할 수 있는가에 대한 주제를 다룬 책인 것 같습니다.

웹 개발을 진로로 선택한 이유 중 하나로 기술에 대한 논의가 공개적이면서 활발하고, 선배들의 시행착오(~~삽질~~)들이 기꺼이 인터넷을 통해 가장 많이 공유되고 있다고 느꼈기 때문입니다. 이 책 또한 그런 시행착오들을 모아 타입스크립트 개발을 할 때 지켜야 할 것과 하지 말아야 할 것을 명쾌히 해주는 것 같네요. 가이드라인이 부족하고 자유도가 높은 기술은 무궁무진하지만 러닝 커브가 높은 것 같습니다. 개인적으로 기술보다 프로덕트에 더 관심이 있어서 기술을 익히는 시간을 줄이고 싶(근데 불가능) 이런 책이 있다는 것에 감사하며 1장 읽었습니다.
